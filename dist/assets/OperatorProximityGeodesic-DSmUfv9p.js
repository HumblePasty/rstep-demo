import{kO as Pe,kM as T,kE as fe,fz as b,kJ as I,ll as Ee,kU as K,kN as _e,lu as Te,ly as ee,kX as j,lB as H,lC as ue,lp as Ie,kH as M,kR as D,lD as Ge,lE as be,ln as De,kK as k,lF as ve,lG as me,l9 as Re,kQ as je,lH as J,l0 as se,lk as re,lI as ye,l4 as oe,lJ as de,fB as Q,k$ as z,l3 as W,fC as $,lx as we,lK as Se,lL as ke,l7 as xe}from"./index-CW6gHi3a.js";import{o as qe}from"./OperatorShapePreservingDensify-Dr5mwsAx.js";function v(){return R(new I,-1,Number.NaN)}function R(o,e,t){return{m_coordinate:o.clone(),m_vertexIndex:e,m_geometryIndex:0,m_distance:t,m_bRightSide:!1,isEmpty:Ue}}function Ue(){return Number.isNaN(this.m_distance)}function te(o,e,t=-1,n=-1){if(o.isEmpty())return 3;const s=o.getGeometryType();if(Pe(s))return Ve(o,e,t,n);if(s===T.enumPolygon)return Xe(o,e,t,n);if(s===T.enumPolyline)return Be(o,e,t,n);if(s===T.enumEnvelope){const r=new fe;return o.queryEnvelope(r),r.contains(e)?r.containsExclusive(e)?1:2:0}return 3}function Ve(o,e,t,n){if(t>=0||n>=0)return b("");if(o.isDegenerate(0))return o.getStartXY().equals(e)?2:3;if(!o.isCurve()){const f=I.orientationRobust(e,o.getStartXY(),o.getEndXY());return f<0?1:f>0?0:2}const s=o.getClosestCoordinate(e,!1),r=o.getTangent(s),m=o.getCoord2D(s),l=I.orientationRobust(e,m,m.add(r));return l<0?1:l>0?0:2}function Xe(o,e,t,n){(t>=0||n>=0)&&b("");const s=new fe;o.queryEnvelope(s);const r=Ee(o,e,0);return r===0?0:r===1?1:2}function Be(o,e,t,n){(t<0&&n>=0||t>=0&&n<0)&&b("");const s=o.querySegmentIterator();if(t<0){let m=Number.MAX_VALUE,l=0;for(;s.nextPath();)for(;s.hasNextSegment();){const f=s.nextSegment(),c=f.getClosestCoordinate(e,!1),u=f.getCoord2D(c),x=I.sqrDistance(u,e);x<m?(l=1,t=s.getStartPointIndex(),n=s.getPathIndex(),m=x):x===m&&l++}if(l===0)return 3;if(l===1)return s.resetToVertex(t,n),te(s.nextSegment(),e)}const r=Fe();if(r.i1!==-1&&r.i2===-1)return r.bRight1?1:0;if(r.i1!==-1&&r.i2!==-1){if(r.bRight1===r.bRight2)return r.bRight1?1:0;{s.resetToVertex(r.i1,-1);const m=s.nextSegment().getTangent(1);s.resetToVertex(r.i2,-1);const l=s.nextSegment().getTangent(0);return m.crossProduct(l)>=0?1:0}}return s.resetToVertex(t,n),te(s.nextSegment(),e)}function Fe(o,e,t,n){return K(0),{}}class Je{getOperatorType(){return 10501}supportsCurves(){return!1}accelerateGeometry(e,t,n){return!1}canAccelerateGeometry(e){return!1}getNearestCoordinate(e,t,n,s,r,m){if(t.isNAN()&&b("NAN xy coordinates are not allowed"),e.isEmpty())return v();if(Number.isNaN(s)&&(s=0),s>=0||b("maxDeviationMeters"),e.getDimension()===0)return this.getNearestVertex(e,t,n);const l=e.getGeometryType();if(l===T.enumGeometryCollection){const P=e;let A=v();for(let G=0,w=P.getGeometryCount();G<w;++G){const F=P.getGeometry(G),V=this.getNearestCoordinate(F,t,n,s,r,m);if(!V.isEmpty()){if(V.m_distance===0)return V;V.m_distance>=A.m_distance||(A=V,A.m_geometryIndex=G)}}return A}if(l===T.enumEnvelope){const P=new _e;return P.addEnvelope(e,!1),this.getNearestCoordinate(P,t,n,s,r,m)}Te(l)||ee("Operation is not implemented for this geometry type");const f=e;if((r||m)&&l===T.enumPolygon){const P=()=>{const A=R(t,-1,0);return A.m_bRightSide=!0,A};if(n.isPannable()){const A=new j().foldInto360Range(new H(t),n);if(A.isEmpty())return v();const G=new j().foldInto360Range(e,n);if(G.isEmpty())return v();if(new ue().execute(G,A,n,null)&&r)return P()}else{const A=new j().clipToSpatialReference(new H(t),n,null,1);if(A.isEmpty())return v();const G=Ie(f,n,0,null);if(G.isEmpty())return v();if(new ue().execute(G,A,n,null)&&r)return P()}}const c=n!==n.getGCS()?n.getSRToGCSTransform():null,u=new I;if(c?new j().transform(c,[t],1,[u],!1):u.assign(t),u.isNAN())return v();const x=ge(f,t,n,1);let y=x.m_distance;if(y===0)return x;Number.isNaN(y)?y=Number.POSITIVE_INFINITY:y*=1+1e-7;const h=n.getGCS(),C=h.getUnit().getUnitToBaseFactor(),_=u.clone();_.scale(C);const g=M();n.querySpheroidData(g);const a=D(g.majorSemiAxis,g.e2,_),N=Ge(g.majorSemiAxis,g.e2),p=new Me(f.querySegmentIterator());s===0&&(s=.01);const d=g.majorSemiAxis*be(45),i=new qe().executeMany(p,n,d,s,0,null),S=[];let B=-1;const Z=new k,Y=new De;for(let P=i.next();P!==null;P=i.next()){if(P.isEmpty())continue;const A=i.getGeometryID(),G=e.getPathIndexFromPointIndex(A);e.isClosedPath(G)&&f.getPathEnd(G);const w=P;for(let F=0,V=w.getPathCount();F<V;++F){S.length=0;for(let E=w.getPathStart(F),X=w.getPathEnd(F);E<X;++E)S.push(w.getXY(E));if(c&&new j().transform(c,S,S.length,S,!1),S.length>3){const E=Ne(S,S.length,u,h,1);if(E.m_distance<y){y=E.m_distance,Z.assign(D(g.majorSemiAxis,g.e2,E.m_coordinate.mul(C))),B=A;let X=E.m_vertexIndex;X+1===S.length&&(X-=1),w.getSegmentBuffer(X,Y,!0)}}S.forEach(E=>E.mulThis(C));const L=D(g.majorSemiAxis,g.e2,S[0]),Ae=new k;for(let E=1,X=S.length;E<X;++E){const O=D(g.majorSemiAxis,g.e2,S[E]);if(ve(N,a,L,O,Ae)<y){const{first:Le,second:Ce}=me(g.majorSemiAxis,g.e2,a,L,O,2,null);if(Ce<=y){const ce=new k,{first:Oe,second:le}=me(g.majorSemiAxis,g.e2,a,L,O,0,ce);le<y&&(y=le,Z.assign(ce),B=A,w.getSegmentBuffer(E-1,Y,!0))}}L.assign(O)}}}if(!Number.isFinite(y))return v();B===-1&&b("");const q=Re(g.majorSemiAxis,g.e2,Z);q.divThis(C);const U=q.clone(),ie=n!==n.getGCS()?n.getGCSToSRTransform():null;ie&&new j().transform(ie,[q],1,[U],!1),U.isNAN()&&je("closestPoint2DSr.isNAN()"),K(!Y.empty());const he=Y.get().getClosestCoordinate(U,!1);U.assign(Y.get().getCoord2D(he)),c?new j().transform(c,[U],1,[q],!1):q.assign(U),K(!q.isNAN());const pe=this.getNearestVertex(new H(q),u,n.getGCS()),ae=R(U,B,pe.m_distance);if(m&&e.getDimension()>0){const P=te(e,t,-1,-1),A=P!==0&&P!==3;ae.m_bRightSide=A}return ae}getNearestVertex(e,t,n){if(t.isNAN()&&b("NAN xy coordinates are not allowed"),e.isEmpty())return v();switch(e.getGeometryType()){case T.enumPoint:return ne(e,t,n);case T.enumMultiPoint:case T.enumPolyline:case T.enumPolygon:return ge(e,t,n);default:ee("")}}getNearestVertexPoint2D(e,t,n,s){return K(0),{}}getNearestVertices(e,t,n,s,r){if(t.isNAN()&&b("NAN xy coordinates are not allowed"),e.isEmpty())return[];switch(e.getGeometryType()){case T.enumPoint:{const m=ne(e,t,n);if(!m.isEmpty()&&m.m_distance<s&&r>=1){const l=[];return l.push(m),l}return[]}case T.enumMultiPoint:case T.enumPolyline:case T.enumPolygon:return Ye(e,t,n,s,r);default:ee("")}}}function ne(o,e,t){const n={stack:[],error:void 0,hasError:!1};try{if(t.getCoordinateSystemType()===0&&b("Cannot use local SR"),t.getCoordinateSystemType()!==1){const u=new Array(2);u[0]=o.getXY(),u[1]=e.clone();const x=Se(I,2);ke(t,u,2,x)!==2&&b("Point cannot be projected to GCS");const y=t.getGCS(),h=ne(new H(x[0]),x[1],y);return R(h.m_coordinate,0,h.m_distance)}const s=t.getUnit().getUnitToBaseFactor(),r=o.getXY();r.scale(s);const m=e.clone();m.scale(s);const l=M();t.querySpheroidData(l);const f=Q(n,new z,!1);W.geodeticDistance(l.majorSemiAxis,l.e2,r.x,r.y,m.x,m.y,f,null,null,xe.PE_LINETYPE_GEODESIC);const c=o.getXY();return R(c,0,f.val)}catch(s){n.error=s,n.hasError=!0}finally{$(n)}}function ge(o,e,t,n=0){t.getCoordinateSystemType()===0&&b("Cannot use local SR");let s=o.getAttributeStreamRef(0),r=o.getPointCount();const m=t.getGCS(),l=e.clone();if(t.getCoordinateSystemType()!==1){const d=t.getSRToGCSTransform();if(J(d,[e],1,[l],null),l.isNAN())return R(I.getNAN(),-1,Number.NaN);const i=new j().execute(o,d,null);s=i.getAttributeStreamRef(0),r=i.getPointCount()}const f=m.getUnit().getUnitToBaseFactor(),c=se(r,0);for(let d=0;d<r;++d)c[d]=d;re(r,c);const u=M();m.querySpheroidData(u);const x=l.clone();x.scale(f);const y=D(u.majorSemiAxis,u.e2,x);let h=-1,C=Number.MAX_VALUE;const _=ye(u.majorSemiAxis,u.e2);let g=r;const a=new I,N=new I;for(let d=0;d<g;){if(s.queryPoint2D(2*c[d],a),a.isNAN())continue;N.assign(a),N.scale(f);const i=D(u.majorSemiAxis,u.e2,N);if(k.distance(i,y)>C){c[g-1]=oe(c[d],c[d]=c[g-1]),g--;continue}const S=de(_,i,y);S<C&&(h=c[d],C=S),d++}if(u.e2!==0){const d={stack:[],error:void 0,hasError:!1};try{const i=Q(d,new z,!1);for(let S=0;S<g;S++){if(s.queryPoint2D(2*c[S],a),a.isNAN())continue;N.assign(a),N.scale(f);const B=D(u.majorSemiAxis,u.e2,N);k.distance(B,y)>C||(W.geodeticDistance(u.majorSemiAxis,u.e2,x.x,x.y,N.x,N.y,i,null,null,n),i.val<C&&(h=c[S],C=i.val))}}catch(i){d.error=i,d.hasError=!0}finally{$(d)}}const p=new I;return h!==-1&&p.assign(o.getXY(h)),R(p,h,C)}function Ne(o,e,t,n,s=0){n.getCoordinateSystemType()===0&&b("Cannot use local SR");const r=n.getGCS(),m=t.clone();if(n.getCoordinateSystemType()!==1){const a=n.getSRToGCSTransform();if(J(a,[t],1,[m],null),m.isNAN())return v();const N=Se(I,e);J(a,o,e,N,null);const p=Ne(N,e,t,r,s);return p.isEmpty()?p:R(o[p.m_vertexIndex],p.m_vertexIndex,p.m_distance)}const l=r.getUnit().getUnitToBaseFactor(),f=se(e,0);for(let a=0;a<e;++a)f[a]=a;re(e,f);const c=M();r.querySpheroidData(c);const u=m.clone();u.scale(l);const x=D(c.majorSemiAxis,c.e2,u);let y=-1,h=Number.MAX_VALUE;const C=ye(c.majorSemiAxis,c.e2);let _=e;for(let a=0;a<_;){const N=o[f[a]];if(N.isNAN())continue;const p=N.clone();p.scale(l);const d=D(c.majorSemiAxis,c.e2,p);if(k.distance(d,x)>h){f[_-1]=oe(f[a],f[a]=f[_-1]),_--;continue}const i=de(C,d,x);i<h&&(y=f[a],h=i),a++}if(c.e2!==0){const a={stack:[],error:void 0,hasError:!1};try{const N=Q(a,new z,!1);for(let p=0;p<_;p++){const d=o[f[p]];if(d.isNAN())continue;const i=d.clone();i.scale(l);const S=D(c.majorSemiAxis,c.e2,i);k.distance(S,x)>h||(W.geodeticDistance(c.majorSemiAxis,c.e2,u.x,u.y,i.x,i.y,N,null,null,s),N.val<h&&(y=f[p],h=N.val))}}catch(N){a.error=N,a.hasError=!0}finally{$(a)}}const g=new I;return y!==-1&&g.assign(o[y]),R(g,y,h)}function Ye(o,e,t,n,s){const r={stack:[],error:void 0,hasError:!1};try{t.getCoordinateSystemType()===0&&b("Cannot use local SR");let m=o.getAttributeStreamRef(0),l=o.getPointCount();const f=t.getGCS(),c=e.clone();if(t.getCoordinateSystemType()!==1){const i=t.getSRToGCSTransform();if(J(i,[e],1,[c],null),c.isNAN())return[];const S=new j().execute(o,i,null);m=S.getAttributeStreamRef(0),l=S.getPointCount()}const u=f.getUnit().getUnitToBaseFactor(),x=se(l,0);for(let i=0;i<l;++i)x[i]=i;re(l,x);const y=M();f.querySpheroidData(y);const h=c.clone();h.scale(u);const C=D(y.majorSemiAxis,y.e2,h),_=[];let g=l;const a=new I,N=new I;for(let i=0;i<g;){if(m.queryPoint2D(2*x[i],a),a.isNAN())continue;N.assign(a),N.scale(u);const S=D(y.majorSemiAxis,y.e2,N);k.distance(S,C)>n?(x[g-1]=oe(x[i],x[i]=x[g-1]),g--):i++}const p=(i,S)=>i.m_distance-S.m_distance,d=Q(r,new z,!1);for(let i=0;i<g;i++)m.queryPoint2D(2*x[i],a),a.isNAN()||(W.geodeticDistance(y.majorSemiAxis,y.e2,h.x,h.y,a.x*u,a.y*u,d,null,null,xe.PE_LINETYPE_GEODESIC),d.val<n&&_.push(R(a,x[i],d.val)));return _.sort(p),_.slice(0,s)}catch(m){r.error=m,r.hasError=!0}finally{$(r)}}class Me extends we{constructor(e){super(),this.m_first=!0,this.m_segIter=e,this.m_segIter.stripAttributes()}tock(){return!0}getRank(){return 1}next(){if(this.m_first){if(!this.m_segIter.nextPath())return null;this.m_first=!1}for(;;){if(this.m_segIter.hasNextSegment())return this.m_segIter.nextSegment().clone();if(!this.m_segIter.nextPath())break}return null}getGeometryID(){return this.m_segIter.getStartPointIndex()}}export{Je as OperatorProximityGeodesic};
