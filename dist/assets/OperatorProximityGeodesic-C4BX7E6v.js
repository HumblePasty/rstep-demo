import{kV as Pe,kT as _,kL as fe,fz as G,kQ as I,ls as Ee,k$ as Q,kU as Te,lB as _e,lF as ee,l2 as j,lI as K,lJ as ue,lw as Ie,kO as M,kY as R,lK as be,lL as Ge,lu as Re,kR as k,lM as ve,lN as me,lg as De,kX as je,lO as z,l7 as se,lr as re,lP as ye,lb as oe,lQ as Se,fB as J,l6 as W,la as $,fC as H,lE as we,lR as de,lS as ke,le as xe}from"./index-BlU5-B7d.js";import{o as qe}from"./OperatorShapePreservingDensify-CmTdM5it.js";function v(){return D(new I,-1,Number.NaN)}function D(o,e,t){return{m_coordinate:o.clone(),m_vertexIndex:e,m_geometryIndex:0,m_distance:t,m_bRightSide:!1,isEmpty:Ve}}function Ve(){return Number.isNaN(this.m_distance)}function te(o,e,t=-1,n=-1){if(o.isEmpty())return 3;const s=o.getGeometryType();if(Pe(s))return Ue(o,e,t,n);if(s===_.enumPolygon)return Xe(o,e,t,n);if(s===_.enumPolyline)return Ye(o,e,t,n);if(s===_.enumEnvelope){const r=new fe;return o.queryEnvelope(r),r.contains(e)?r.containsExclusive(e)?1:2:0}return 3}function Ue(o,e,t,n){if(t>=0||n>=0)return G("");if(o.isDegenerate(0))return o.getStartXY().equals(e)?2:3;if(!o.isCurve()){const f=I.orientationRobust(e,o.getStartXY(),o.getEndXY());return f<0?1:f>0?0:2}const s=o.getClosestCoordinate(e,!1),r=o.getTangent(s),m=o.getCoord2D(s),l=I.orientationRobust(e,m,m.add(r));return l<0?1:l>0?0:2}function Xe(o,e,t,n){(t>=0||n>=0)&&G("");const s=new fe;o.queryEnvelope(s);const r=Ee(o,e,0);return r===0?0:r===1?1:2}function Ye(o,e,t,n){(t<0&&n>=0||t>=0&&n<0)&&G("");const s=o.querySegmentIterator();if(t<0){let m=Number.MAX_VALUE,l=0;for(;s.nextPath();)for(;s.hasNextSegment();){const f=s.nextSegment(),c=f.getClosestCoordinate(e,!1),u=f.getCoord2D(c),x=I.sqrDistance(u,e);x<m?(l=1,t=s.getStartPointIndex(),n=s.getPathIndex(),m=x):x===m&&l++}if(l===0)return 3;if(l===1)return s.resetToVertex(t,n),te(s.nextSegment(),e)}const r=Be();if(r.i1!==-1&&r.i2===-1)return r.bRight1?1:0;if(r.i1!==-1&&r.i2!==-1){if(r.bRight1===r.bRight2)return r.bRight1?1:0;{s.resetToVertex(r.i1,-1);const m=s.nextSegment().getTangent(1);s.resetToVertex(r.i2,-1);const l=s.nextSegment().getTangent(0);return m.crossProduct(l)>=0?1:0}}return s.resetToVertex(t,n),te(s.nextSegment(),e)}function Be(o,e,t,n){return Q(0),{}}class ze{getOperatorType(){return 10501}supportsCurves(){return!1}accelerateGeometry(e,t,n){return!1}canAccelerateGeometry(e){return!1}getNearestCoordinate(e,t,n,s,r,m){if(t.isNAN()&&G("NAN xy coordinates are not allowed"),e.isEmpty())return v();if(Number.isNaN(s)&&(s=0),s>=0||G("maxDeviationMeters"),e.getDimension()===0)return this.getNearestVertex(e,t,n);const l=e.getGeometryType();if(l===_.enumGeometryCollection){const P=e;let A=v();for(let b=0,w=P.getGeometryCount();b<w;++b){const B=P.getGeometry(b),U=this.getNearestCoordinate(B,t,n,s,r,m);if(!U.isEmpty()){if(U.m_distance===0)return U;U.m_distance>=A.m_distance||(A=U,A.m_geometryIndex=b)}}return A}if(l===_.enumEnvelope){const P=new Te;return P.addEnvelope(e,!1),this.getNearestCoordinate(P,t,n,s,r,m)}_e(l)||ee("Operation is not implemented for this geometry type");const f=e;if((r||m)&&l===_.enumPolygon){const P=()=>{const A=D(t,-1,0);return A.m_bRightSide=!0,A};if(n.isPannable()){const A=new j().foldInto360Range(new K(t),n);if(A.isEmpty())return v();const b=new j().foldInto360Range(e,n);if(b.isEmpty())return v();if(new ue().execute(b,A,n,null)&&r)return P()}else{const A=new j().clipToSpatialReference(new K(t),n,null,1);if(A.isEmpty())return v();const b=Ie(f,n,0,null);if(b.isEmpty())return v();if(new ue().execute(b,A,n,null)&&r)return P()}}const c=n!==n.getGCS()?n.getSRToGCSTransform():null,u=new I;if(c?new j().transform(c,[t],1,[u],!1):u.assign(t),u.isNAN())return v();const x=ge(f,t,n,1);let y=x.m_distance;if(y===0)return x;Number.isNaN(y)?y=Number.POSITIVE_INFINITY:y*=1+1e-7;const h=n.getGCS(),C=h.getUnit().getUnitToBaseFactor(),T=u.clone();T.scale(C);const g=M();n.querySpheroidData(g);const a=R(g.majorSemiAxis,g.e2,T),N=be(g.majorSemiAxis,g.e2),p=new Me(f.querySegmentIterator());s===0&&(s=.01);const S=g.majorSemiAxis*Ge(45),i=new qe().executeMany(p,n,S,s,0,null),d=[];let Y=-1;const Z=new k,F=new Re;for(let P=i.next();P!==null;P=i.next()){if(P.isEmpty())continue;const A=i.getGeometryID(),b=e.getPathIndexFromPointIndex(A);e.isClosedPath(b)&&f.getPathEnd(b);const w=P;for(let B=0,U=w.getPathCount();B<U;++B){d.length=0;for(let E=w.getPathStart(B),X=w.getPathEnd(B);E<X;++E)d.push(w.getXY(E));if(c&&new j().transform(c,d,d.length,d,!1),d.length>3){const E=Ne(d,d.length,u,h,1);if(E.m_distance<y){y=E.m_distance,Z.assign(R(g.majorSemiAxis,g.e2,E.m_coordinate.mul(C))),Y=A;let X=E.m_vertexIndex;X+1===d.length&&(X-=1),w.getSegmentBuffer(X,F,!0)}}d.forEach(E=>E.mulThis(C));const L=R(g.majorSemiAxis,g.e2,d[0]),Ae=new k;for(let E=1,X=d.length;E<X;++E){const O=R(g.majorSemiAxis,g.e2,d[E]);if(ve(N,a,L,O,Ae)<y){const{first:Le,second:Ce}=me(g.majorSemiAxis,g.e2,a,L,O,2,null);if(Ce<=y){const ce=new k,{first:Oe,second:le}=me(g.majorSemiAxis,g.e2,a,L,O,0,ce);le<y&&(y=le,Z.assign(ce),Y=A,w.getSegmentBuffer(E-1,F,!0))}}L.assign(O)}}}if(!Number.isFinite(y))return v();Y===-1&&G("");const q=De(g.majorSemiAxis,g.e2,Z);q.divThis(C);const V=q.clone(),ie=n!==n.getGCS()?n.getGCSToSRTransform():null;ie&&new j().transform(ie,[q],1,[V],!1),V.isNAN()&&je("closestPoint2DSr.isNAN()"),Q(!F.empty());const he=F.get().getClosestCoordinate(V,!1);V.assign(F.get().getCoord2D(he)),c?new j().transform(c,[V],1,[q],!1):q.assign(V),Q(!q.isNAN());const pe=this.getNearestVertex(new K(q),u,n.getGCS()),ae=D(V,Y,pe.m_distance);if(m&&e.getDimension()>0){const P=te(e,t,-1,-1),A=P!==0&&P!==3;ae.m_bRightSide=A}return ae}getNearestVertex(e,t,n){if(t.isNAN()&&G("NAN xy coordinates are not allowed"),e.isEmpty())return v();switch(e.getGeometryType()){case _.enumPoint:return ne(e,t,n);case _.enumMultiPoint:case _.enumPolyline:case _.enumPolygon:return ge(e,t,n);default:ee("")}}getNearestVertexPoint2D(e,t,n,s){return Q(0),{}}getNearestVertices(e,t,n,s,r){if(t.isNAN()&&G("NAN xy coordinates are not allowed"),e.isEmpty())return[];switch(e.getGeometryType()){case _.enumPoint:{const m=ne(e,t,n);if(!m.isEmpty()&&m.m_distance<s&&r>=1){const l=[];return l.push(m),l}return[]}case _.enumMultiPoint:case _.enumPolyline:case _.enumPolygon:return Fe(e,t,n,s,r);default:ee("")}}}function ne(o,e,t){const n={stack:[],error:void 0,hasError:!1};try{if(t.getCoordinateSystemType()===0&&G("Cannot use local SR"),t.getCoordinateSystemType()!==1){const u=new Array(2);u[0]=o.getXY(),u[1]=e.clone();const x=de(I,2);ke(t,u,2,x)!==2&&G("Point cannot be projected to GCS");const y=t.getGCS(),h=ne(new K(x[0]),x[1],y);return D(h.m_coordinate,0,h.m_distance)}const s=t.getUnit().getUnitToBaseFactor(),r=o.getXY();r.scale(s);const m=e.clone();m.scale(s);const l=M();t.querySpheroidData(l);const f=J(n,new W,!1);$.geodeticDistance(l.majorSemiAxis,l.e2,r.x,r.y,m.x,m.y,f,null,null,xe.PE_LINETYPE_GEODESIC);const c=o.getXY();return D(c,0,f.val)}catch(s){n.error=s,n.hasError=!0}finally{H(n)}}function ge(o,e,t,n=0){t.getCoordinateSystemType()===0&&G("Cannot use local SR");let s=o.getAttributeStreamRef(0),r=o.getPointCount();const m=t.getGCS(),l=e.clone();if(t.getCoordinateSystemType()!==1){const S=t.getSRToGCSTransform();if(z(S,[e],1,[l],null),l.isNAN())return D(I.getNAN(),-1,Number.NaN);const i=new j().execute(o,S,null);s=i.getAttributeStreamRef(0),r=i.getPointCount()}const f=m.getUnit().getUnitToBaseFactor(),c=se(r,0);for(let S=0;S<r;++S)c[S]=S;re(r,c);const u=M();m.querySpheroidData(u);const x=l.clone();x.scale(f);const y=R(u.majorSemiAxis,u.e2,x);let h=-1,C=Number.MAX_VALUE;const T=ye(u.majorSemiAxis,u.e2);let g=r;const a=new I,N=new I;for(let S=0;S<g;){if(s.queryPoint2D(2*c[S],a),a.isNAN())continue;N.assign(a),N.scale(f);const i=R(u.majorSemiAxis,u.e2,N);if(k.distance(i,y)>C){c[g-1]=oe(c[S],c[S]=c[g-1]),g--;continue}const d=Se(T,i,y);d<C&&(h=c[S],C=d),S++}if(u.e2!==0){const S={stack:[],error:void 0,hasError:!1};try{const i=J(S,new W,!1);for(let d=0;d<g;d++){if(s.queryPoint2D(2*c[d],a),a.isNAN())continue;N.assign(a),N.scale(f);const Y=R(u.majorSemiAxis,u.e2,N);k.distance(Y,y)>C||($.geodeticDistance(u.majorSemiAxis,u.e2,x.x,x.y,N.x,N.y,i,null,null,n),i.val<C&&(h=c[d],C=i.val))}}catch(i){S.error=i,S.hasError=!0}finally{H(S)}}const p=new I;return h!==-1&&p.assign(o.getXY(h)),D(p,h,C)}function Ne(o,e,t,n,s=0){n.getCoordinateSystemType()===0&&G("Cannot use local SR");const r=n.getGCS(),m=t.clone();if(n.getCoordinateSystemType()!==1){const a=n.getSRToGCSTransform();if(z(a,[t],1,[m],null),m.isNAN())return v();const N=de(I,e);z(a,o,e,N,null);const p=Ne(N,e,t,r,s);return p.isEmpty()?p:D(o[p.m_vertexIndex],p.m_vertexIndex,p.m_distance)}const l=r.getUnit().getUnitToBaseFactor(),f=se(e,0);for(let a=0;a<e;++a)f[a]=a;re(e,f);const c=M();r.querySpheroidData(c);const u=m.clone();u.scale(l);const x=R(c.majorSemiAxis,c.e2,u);let y=-1,h=Number.MAX_VALUE;const C=ye(c.majorSemiAxis,c.e2);let T=e;for(let a=0;a<T;){const N=o[f[a]];if(N.isNAN())continue;const p=N.clone();p.scale(l);const S=R(c.majorSemiAxis,c.e2,p);if(k.distance(S,x)>h){f[T-1]=oe(f[a],f[a]=f[T-1]),T--;continue}const i=Se(C,S,x);i<h&&(y=f[a],h=i),a++}if(c.e2!==0){const a={stack:[],error:void 0,hasError:!1};try{const N=J(a,new W,!1);for(let p=0;p<T;p++){const S=o[f[p]];if(S.isNAN())continue;const i=S.clone();i.scale(l);const d=R(c.majorSemiAxis,c.e2,i);k.distance(d,x)>h||($.geodeticDistance(c.majorSemiAxis,c.e2,u.x,u.y,i.x,i.y,N,null,null,s),N.val<h&&(y=f[p],h=N.val))}}catch(N){a.error=N,a.hasError=!0}finally{H(a)}}const g=new I;return y!==-1&&g.assign(o[y]),D(g,y,h)}function Fe(o,e,t,n,s){const r={stack:[],error:void 0,hasError:!1};try{t.getCoordinateSystemType()===0&&G("Cannot use local SR");let m=o.getAttributeStreamRef(0),l=o.getPointCount();const f=t.getGCS(),c=e.clone();if(t.getCoordinateSystemType()!==1){const i=t.getSRToGCSTransform();if(z(i,[e],1,[c],null),c.isNAN())return[];const d=new j().execute(o,i,null);m=d.getAttributeStreamRef(0),l=d.getPointCount()}const u=f.getUnit().getUnitToBaseFactor(),x=se(l,0);for(let i=0;i<l;++i)x[i]=i;re(l,x);const y=M();f.querySpheroidData(y);const h=c.clone();h.scale(u);const C=R(y.majorSemiAxis,y.e2,h),T=[];let g=l;const a=new I,N=new I;for(let i=0;i<g;){if(m.queryPoint2D(2*x[i],a),a.isNAN())continue;N.assign(a),N.scale(u);const d=R(y.majorSemiAxis,y.e2,N);k.distance(d,C)>n?(x[g-1]=oe(x[i],x[i]=x[g-1]),g--):i++}const p=(i,d)=>i.m_distance-d.m_distance,S=J(r,new W,!1);for(let i=0;i<g;i++)m.queryPoint2D(2*x[i],a),a.isNAN()||($.geodeticDistance(y.majorSemiAxis,y.e2,h.x,h.y,a.x*u,a.y*u,S,null,null,xe.PE_LINETYPE_GEODESIC),S.val<n&&T.push(D(a,x[i],S.val)));return T.sort(p),T.slice(0,s)}catch(m){r.error=m,r.hasError=!0}finally{H(r)}}class Me extends we{constructor(e){super(),this.m_first=!0,this.m_segIter=e,this.m_segIter.stripAttributes()}tock(){return!0}getRank(){return 1}next(){if(this.m_first){if(!this.m_segIter.nextPath())return null;this.m_first=!1}for(;;){if(this.m_segIter.hasNextSegment())return this.m_segIter.nextSegment().clone();if(!this.m_segIter.nextPath())break}return null}getGeometryID(){return this.m_segIter.getStartPointIndex()}}export{ze as OperatorProximityGeodesic};
