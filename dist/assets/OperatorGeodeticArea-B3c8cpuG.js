import{kC as ie,kD as Q,kE as G,kF as Pe,kG as Le,kH as se,kI as Ie,kJ as x,kK as y,fz as Se,kL as ae,kM as xe,kN as ye,kO as De,kP as Oe,kQ as Ae,kR as R,fA as ve,kS as de,kT as re,kU as Re,kV as Me,kW as Fe,kX as ne,kY as Je,kZ as he,fB as j,fC as oe,k_ as Ue,k$ as me,l0 as Ye,l1 as V,l2 as W,l3 as le,l4 as Xe,l5 as Te,l6 as Ce,l7 as I,l8 as N,l9 as X,la as we,lb as Ne,lc as te,ld as B,le as F,lf as Be,lg as Ee,lh as ke,li as D,lj as qe}from"./index-CW6gHi3a.js";import{K as He}from"./GeodeticDistanceCalculator-CJvEB3vc-D5wTn8aI.js";import"./OperatorShapePreservingDensify-Dr5mwsAx.js";function ue(){return{m_pGcs:new x,m_xyz:new y,m_factor:Number.NaN,m_geoLength:Number.NaN,setValues:je,setLength:Ve,assign:Qe}}function je(u,e,t,n){this.m_factor=u,this.m_pGcs.assign(e),this.m_xyz.assign(n),this.m_geoLength=t}function Ve(u){this.m_geoLength=u}function Qe(u){this.m_pGcs.assign(u.m_pGcs),this.m_xyz.assign(u.m_xyz),this.m_factor=u.m_factor,this.m_geoLength=u.m_geoLength}class Ze{getOperatorType(){return 10315}supportsCurves(){return!0}accelerateGeometry(e,t,n){return!1}canAccelerateGeometry(e){return!1}_ExecuteShapePreservingLength(e,t,n,i,a){if(e.hasNonLinearSegments()&&(e=new ie().execute(e,0,t.getTolerance(0),0,a)),t.isPannable()){let s=90,_=-90;if(n.getUnit().getUnitToBaseFactor()===1&&(s*=Math.PI/180,_*=Math.PI/180),t.getCoordinateSystemType()===2){let l=null;const m=[0,0,0,0];l=t.getPECoordSys(),m[0]=0,m[1]=s,m[2]=0,m[3]=_,Q.geogToProj(l,2,m),s=m[1],_=m[3]}const r=new G;e.queryEnvelope(r),r.ymin=_,r.ymax=s,e=new Pe().execute(e,r,t,a)}else{const s=t.getPCSHorizon();(e=new Le().execute(e,s,t,a))===s&&(e=e.clone())}return e.isEmpty()?0:this._ExecuteIterativeApproach(e,t,n,i,1,a)}_ExecuteIterativeApproach(e,t,n,i,a,s){const _=se();n.querySpheroidData(_);const r=_.majorSemiAxis,l=_.e2,m=n.getUnit().getUnitToBaseFactor(),o=40,h=Ie(ue,o),p=new Array(o),c=ue(),g=ue();let d;const f=[0,0,0,0],S=t.getPECoordSys(),E=new x,P=new x,M=new x,C=new x,T=new x;let k=0;const O=e.querySegmentIterator();for(;O.nextPath();)for(;O.hasNextSegment();){const J=O.nextSegment();E.assign(J.getStartXY()),P.assign(J.getEndXY()),t.getCoordinateSystemType()===2?(f[0]=E.x,f[1]=E.y,f[2]=P.x,f[3]=P.y,Q.projToGeog(S,2,f),M.x=f[0]*m,M.y=f[1]*m,C.x=f[2]*m,C.y=f[3]*m):(M.setCoordsPoint2D(E),C.setCoordsPoint2D(P),M.scale(m),C.scale(m));const v=new y,$=new y;pe(r,l,M,v),pe(r,l,C,$);let w=K(r,v,$);c.setValues(0,M,Number.NaN,v),g.setValues(1,C,w,$),d=a,h[0].assign(g),p[0]=a;let A=0;for(;;){A>128&&Ae("iterations exceeded");const q=.5*(c.m_factor+g.m_factor),b=J.getCoord2D(q);t.getCoordinateSystemType()===2?(f[0]=b.x,f[1]=b.y,Q.projToGeog(S,1,f),T.x=f[0]*m,T.y=f[1]*m):(T.setCoordsPoint2D(b),T.scale(m)),M.setCoordsPoint2D(c.m_pGcs),C.setCoordsPoint2D(g.m_pGcs);const L=new y;pe(r,l,T,L);const U=K(r,c.m_xyz,L),Y=K(r,g.m_xyz,L);w=g.m_geoLength,Number.isNaN(w)&&(w=K(r,c.m_xyz,g.m_xyz));const z=U+Y,H=d===a&&z>=20&&Math.abs(z-w)>1e-8*(w+z);if(A+2<o&&(H||Math.abs(z-w)>0&&d>0))g.setLength(Y),h[A].assign(g),g.setValues(q,T,U,L),h[++A].assign(g),H?(d=a,p[A]=a):(d--,p[A-1]=d,p[A]=d);else{if(k+=z,A===0)break;c.assign(g),g.assign(h[--A]),d=p[A]}}}return k}execute(e,t,n){if(t&&t.getCoordinateSystemType()!==0||Se(""),e.isEmpty()||e.getDimension()<1)return 0;let i=null;const a=t.getGCS();a!==t&&(i=ae(t,a,null));const s=e.getGeometryType();if(s===xe.enumEnvelope){const _=new ye;return _.addEnvelope(e,!1),this._ExecuteShapePreservingLength(_,t,a,i,n)}if(De(s)){const _=new Oe;return _.addSegment(e,!0),this._ExecuteShapePreservingLength(_,t,a,i,n)}return this._ExecuteShapePreservingLength(e,t,a,i,n)}}function pe(u,e,t,n){n.assign(R(u,e,t))}function K(u,e,t){const n=u,i=new y;i.setSub(e,t);const a=i.length();return 2*n*Math.asin(a/(2*n))}class We{constructor(e,t,n,i,a=100){this.m_startPt=e.clone(),this.m_endPt=t.clone(),this.m_cE2=i,this.m_cE=Math.sqrt(this.m_cE2),this.m_c1By2e=1/(2*this.m_cE),this.m_cRpu=n.getGCS().getUnit().getUnitToBaseFactor(),this.isPcs=n.getCoordinateSystemType()===2,this.PEProjcs=n.getPECoordSys(),this.m_points=new Array(2*a)}setSegmentEndPoints(e,t){this.m_startPt.assign(e),this.m_endPt.assign(t)}makeFunctor(){return e=>{const t=[0,0];t[0]=this.m_startPt.x*(1-e)+this.m_endPt.x*e,t[1]=this.m_startPt.y*(1-e)+this.m_endPt.y*e,this.isPcs&&Q.projToGeogCenter(this.PEProjcs,1,t,0);const n=Math.sin(t[1]*this.m_cRpu);return this.m_cE2===0?n:-Math.log((1-this.m_cE*n)/(1+this.m_cE*n))*this.m_c1By2e+n/(1-this.m_cE2*n*n)}}makeArrayFunctor(){return Re(0),{}}}function Ke(u,e,t){const n=new G;u.queryEnvelope(n);const i=Be(e,n,!0).total(),a=e.getPannableExtent();a.xmin=n.xmin-10*i,a.xmax=n.xmax+10*i;const s=new Pe().execute(u,a,e,t).getImpl().querySegmentIterator();s.stripAttributes();const _=se();e.querySpheroidData(_);const r=_.e2,l=r===0?2:1,m=new x(0,0),o=new x(0,0),h=new V(0),p=new We(m,o,e,r,100);for(;s.nextPath();)for(;s.hasNextSegment();){const g=s.nextSegment();m.assign(g.getStartXY()),o.assign(g.getEndXY()),p.setSegmentEndPoints(m,o);const d=te(6,0,1,1e-12,1e-15,p.makeFunctor());h.pe((o.x-m.x)*d)}const c=_.majorSemiAxis;return l*c*c*(1-r)*Math.PI*h.getResult()/e.getPannableExtent().width()}function et(u,e,t,n,i){const a=nt(u,e,i);let s=be(u,a.first,t,n,i),_=1,r=0,l=0;do{if(_++,a.first*=.5,a.first<50*e.getTolerance(0))return s;a.second*=2,l=be(u,a.first,t,n,i),r=Math.abs(l-s),s=l}while(Math.abs(s)>1&&r>1e-8*Math.abs(s)&&(a.second<65e3&&_<8||_<4));return l}function be(u,e,t,n,i){const a=new ie().execute(u,e,0,0,i);let s;s=n?new ne().execute(a,n,i):a;const _=t.getUnit().getUnitToBaseFactor()===1?Math.PI/180:1,r=new G;s.queryEnvelope(r);const l=new G,m=new G,o=new G;l.setCoords({xmin:r.xmin,ymin:75*_,xmax:r.xmax,ymax:90*_}),m.setCoords({xmin:r.xmin,ymin:-60*_,xmax:r.xmax,ymax:75*_}),o.setCoords({xmin:r.xmin,ymin:-90*_,xmax:r.xmax,ymax:-60*_}),l.inflateCoords(.01*l.width(),0),m.inflateCoords(.01*m.width(),0),o.inflateCoords(.01*o.width(),0);let h=0;return h+=ce(s,l,t,i),h+=ce(s,m,t,i),h+=ce(s,o,t,i),h}function ce(u,e,t,n){const i=new Pe().execute(u,e,t,n);if(i!==null&&!i.isEmpty()){const a=new G;i.queryEnvelope(a);const{first:s,second:_}=st(t,a,!1),r=ae(t,s,null),l=new ne().execute(i,r,n).calculateArea2D();return _&&s.destroy(),l}return 0}const ee=[null,null,null,null,null,null,null];function tt(u,e,t){const n=u.getUnit().getUnitToBaseFactor(),i=e.getCenter();i.scale(180*n/Math.PI);const a=new x;a.x=0,a.y=0;let s=0;if(s===0){i.y>45?(a.y=D,s=0):i.y<-45?(a.y=-D,s=1):i.x>=45&&i.x<135?(a.x=D,s=2):i.x>=135||i.x<-135?(a.x=D,s=3):i.x<-45&&i.x>=-135?(a.x=-D,s=4):(a.x=0,s=5);const S=n*Math.sqrt(qe(e.xmin-e.xmax)+qe(e.ymin-e.ymax)),E=a.clone(),P=e.getCenter();if(P.scale(n),s<2&&(E.x=P.x),x.distance(E,P)+.5*S>D)return null}const _=ee[s];if(_!==null&&_.getGCS().equalHorizontal(u))return _;const r=u.getText(),l=a.x,m=a.y,o=0,h=0;let p=0,c=-1;s!==6?c=I.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA:(Re(t),p=0,c=I.PE_PRJ_CYLINDRICAL_EQAREA);const g=Ce("EqualAreaPCS");let d;c===I.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA?d=`PROJCS["${g}",${r},PROJECTION["Lambert_Azimuthal_Equal_Area"],PARAMETER["False_Easting",${o}],PARAMETER["False_Northing",${h}],PARAMETER["Central_Meridian",${l}],PARAMETER["Latitude_of_Origin",${m}],UNIT["Meter",1.0]]`:c===I.PE_PRJ_CYLINDRICAL_EQAREA?d=`PROJCS["${g}",${r},PROJECTION["Cylindrical_Equal_Area"],PARAMETER["False_Easting",${o}],PARAMETER["False_Northing",${h}],PARAMETER["Central_Meridian",${l}],PARAMETER["Standard_Parallel_1",${p}],PARAMETER["Latitude_of_Origin",${m}],UNIT["Meter",1.0]]`:Ae("getEqualAreaPcsFixed");const f=ke(d);return ee[s]&&ee[s].destroy(),ee[s]=f,f}function st(u,e,t){const n=tt(u,e,t);if(n!==null)return Ee(n,!1);const i=u.getText(),a=u.getUnit().getUnitToBaseFactor(),s=(e.xmin+e.width()/2)*a,_=(e.ymin+e.height()/2)*a,r=0,l=0;let m=0,o=0,h=-1;e.ymin*a>=75*Math.PI/180||e.ymax*a<=-60*Math.PI/180?h=I.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA:e.ymin>0||e.ymax<0?(m=(e.ymin+1/3*e.height())*a,o=(e.ymin+2/3*e.height())*a,h=I.PE_PRJ_ALBERS):(m=(e.ymin+2/3*e.height())*a,h=I.PE_PRJ_CYLINDRICAL_EQAREA);const p=Ce("EqualAreaPCS");let c;return h===I.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA?c=`PROJCS["${p}",${i},PROJECTION["Lambert_Azimuthal_Equal_Area"],PARAMETER["False_Easting",${r}],PARAMETER["False_Northing",${l}],PARAMETER["Central_Meridian",${s}],PARAMETER["Latitude_of_Origin",${_}],UNIT["Meter",1.0]]`:h===I.PE_PRJ_ALBERS?c=`PROJCS["${p}",${i},PROJECTION["Albers"],PARAMETER["False_Easting",${r}],PARAMETER["False_Northing",${l}],PARAMETER["Central_Meridian",${s}],PARAMETER["Standard_Parallel_1",${m}],PARAMETER["Standard_Parallel_2",${o}],PARAMETER["Latitude_of_Origin",${_}],UNIT["Meter",1.0]]`:h===I.PE_PRJ_CYLINDRICAL_EQAREA?c=`PROJCS["${p}",${i},PROJECTION["Cylindrical_Equal_Area"],PARAMETER["False_Easting",${r}],PARAMETER["False_Northing",${l}],PARAMETER["Central_Meridian",${s}],PARAMETER["Standard_Parallel_1",${m}],PARAMETER["Latitude_of_Origin",${_}],UNIT["Meter",1.0]]`:Ae("getEqualAreaPCSInstance"),Ee(ke(c),!0)}function nt(u,e,t){const n=u.calculateLength2D(),i=new Ze().execute(u,e,t)/25e3,a=n/u.getSegmentCount()*2;let s=Math.min(a,n/i);return s===0&&(s=1),Ee(s,n/s)}class it{getOperatorType(){return 10314}supportsCurves(){return!0}accelerateGeometry(e,t,n){return!1}canAccelerateGeometry(e){return!1}execute(e,t,n){if(t.getCoordinateSystemType()===0&&Se(""),e.isEmpty()||e.getDimension()<2)return 0;if(ve(e),e.getGeometryType()===xe.enumEnvelope){const l=new ye;return l.addEnvelope(e,!1),this.execute(l,t,n)}let i=e;e.getDescription().getAttributeCount()>1&&(i=e.clone(),i.dropAllAttributes());const a=new ie().execute(i,0,t.getTolerance(0),0,n);let s=null;const _=t.getGCS();_!==t&&(s=ae(t,_));let r=new de().execute(a,t,!1,n);return r.isEmpty()?0:(r===e&&(r=e.clone()),t.isPannable()?Ke(r,t,n):et(r,t,_,s,n))}}function ge(){return{m_p_PCS:new x,m_factor:Number.NaN,setValues:at,assign:_t}}function at(u,e){this.m_factor=u,this.m_p_PCS.assign(e)}function _t(u){this.m_factor=u.m_factor,this.m_p_PCS.assign(u.m_p_PCS)}class rt{constructor(e,t,n,i){this.m_ptStart=new y,this.m_ptEnd=new y,this.m_ptStart.assign(t),this.m_ptEnd.assign(n),this.m_deltaX=this.m_ptEnd.x-this.m_ptStart.x,this.m_deltaY=this.m_ptEnd.y-this.m_ptStart.y,this.m_e=Math.sqrt(e),this.m_e2=e,this.m_c1MinusE2=1-e;const a=Math.sin(i);let s;s=this.m_e2===0?2*a:a*(B(this.m_e*a)+1/(1-this.m_e2*a*a)),this.m_baseA=s}setSegmentEndPoints(e,t){this.m_ptStart.assign(e),this.m_ptEnd.assign(t),this.m_deltaX=this.m_ptEnd.x-this.m_ptStart.x,this.m_deltaY=this.m_ptEnd.y-this.m_ptStart.y}makeFunctor(){return e=>{const t=1-e,n=t*this.m_ptStart.x+e*this.m_ptEnd.x,i=t*this.m_ptStart.y+e*this.m_ptEnd.y,a=t*this.m_ptStart.z+e*this.m_ptEnd.z,s=n*n+i*i,_=a/Math.sqrt(a*a+this.m_c1MinusE2*this.m_c1MinusE2*s);let r;return this.m_e2===0?r=2*_:r=_*(B(this.m_e*_)+1/(1-this.m_e2*_*_)),(this.m_deltaY*n-this.m_deltaX*i)/s*(r-this.m_baseA)}}}function ht(){return{e:Number.NaN,one_p_e:Number.NaN,one_m_e:Number.NaN,one_m_e_2:Number.NaN,atanh_e_over_e:Number.NaN,half_qp:Number.NaN,f:Number.NaN,z:Number.NaN}}function fe(){return{sin_phi:Number.NaN,one_p_sin_phi:Number.NaN,one_m_sin_phi:Number.NaN,one_m_e_2_sin_2_phi:Number.NaN,sin_half_phi_pf:Number.NaN,sin_half_phi_pz:Number.NaN,sin_half_asin_e_sin_phi_pf:Number.NaN,sin_half_asin_e_sin_phi_pz:Number.NaN,atanh_sin_phi:Number.NaN,atanh_esin_phi:Number.NaN,make_negative:!1,initialize:ot,changeSign:mt,assign:lt,clone:ut}}function ot(u,e,t,n){const i=.5*u;this.sin_phi=Math.sin(u);const a=e*this.sin_phi,s=.5*Math.asin(a);this.one_p_sin_phi=1+this.sin_phi,this.one_m_sin_phi=1-this.sin_phi,this.one_m_e_2_sin_2_phi=(1+a)*(1-a),this.sin_half_phi_pf=Math.sin(i+t),this.sin_half_phi_pz=Math.sin(i+n),this.sin_half_asin_e_sin_phi_pf=Math.sin(s+t),this.sin_half_asin_e_sin_phi_pz=Math.sin(s+n),this.atanh_sin_phi=Math.log(this.sin_half_phi_pf/this.sin_half_phi_pz),this.atanh_esin_phi=Math.log(this.sin_half_asin_e_sin_phi_pf/this.sin_half_asin_e_sin_phi_pz)}function mt(){this.sin_phi=-this.sin_phi;let u=this.one_p_sin_phi;this.one_p_sin_phi=this.one_m_sin_phi,this.one_m_sin_phi=u,u=this.sin_half_phi_pf,this.sin_half_phi_pf=this.sin_half_phi_pz,this.sin_half_phi_pz=u,u=this.sin_half_asin_e_sin_phi_pf,this.sin_half_asin_e_sin_phi_pf=this.sin_half_asin_e_sin_phi_pz,this.sin_half_asin_e_sin_phi_pz=u,this.atanh_sin_phi=-this.atanh_sin_phi,this.atanh_esin_phi=-this.atanh_esin_phi}function lt(u){this.sin_phi=u.sin_phi,this.one_p_sin_phi=u.one_p_sin_phi,this.one_m_sin_phi=u.one_m_sin_phi,this.one_m_e_2_sin_2_phi=u.one_m_e_2_sin_2_phi,this.sin_half_phi_pf=u.sin_half_phi_pf,this.sin_half_phi_pz=u.sin_half_phi_pz,this.sin_half_asin_e_sin_phi_pf=u.sin_half_asin_e_sin_phi_pf,this.sin_half_asin_e_sin_phi_pz=u.sin_half_asin_e_sin_phi_pz,this.atanh_sin_phi=u.atanh_sin_phi,this.atanh_esin_phi=u.atanh_esin_phi,this.make_negative=u.make_negative}function ut(){return{...this}}class pt{constructor(e,t,n){this.m_transformPCS2GCS=null,this.m_scaleToRadians=new re,this.m_scaleToDegrees=new re,this.m_progressTracker=n,Re(t!==4),this.m_curveType=t,this.m_inputSR=e,e&&e.getCoordinateSystemType()!==0||Se(""),this.m_inputGCS=e.getGCS(),this.m_a=0,this.m_eSquared=0,this.m_b=0,this.m_rpu=0}executePolygonGeodeticArea(e){let t,n=e.clone();if(n.dropAllAttributes(),e.hasNonLinearSegments()&&(n=new ie().execute(n,0,this.m_inputSR.getTolerance(0),0,this.m_progressTracker)),this.m_inputSR.isPannable()){const s=new G;n.queryEnvelope(s);const _=this.m_inputSR.getPannableExtent();if(!_.containsEnvelope(s)){const r=_.getCenterX()-s.getCenterX(),l=new re;l.setShiftCoords(r,0),n.applyTransformation(l),s.move(r,0);const m=new Me;_.queryIntervalX(m);const o=new Me;s.queryIntervalX(o),n=m.contains(o)?Fe(n,this.m_inputSR):new ne().foldInto360RangeGeodetic(n,this.m_inputSR,this.m_curveType)}}if(this.m_transformPCS2GCS?(n=new de().execute(n,this.m_inputSR,!1,this.m_progressTracker),t=n.createInstance(),Je(this.m_transformPCS2GCS,n,t,this.m_progressTracker)||(t=new ne().execute(n,this.m_transformPCS2GCS,this.m_progressTracker))):t=new de().execute(n,this.m_inputGCS,!1,this.m_progressTracker),t.isEmpty())return 0;if(this.m_curveType===1){const s=se();return this.m_inputGCS.querySpheroidData(s),this.m_a=s.majorSemiAxis,this.m_eSquared=s.e2,this.loxodromeArea(t)}const i=t.getImpl();this.m_rpu=this.m_inputGCS.getUnit().getUnitToBaseFactor(),this.m_scaleToRadians.setScale(this.m_rpu),i.applyTransformation(this.m_scaleToRadians),this.m_scaleToDegrees=this.m_scaleToRadians,this.m_scaleToDegrees.invertThis();const a=se();if(this.m_inputGCS.querySpheroidData(a),this.m_a=a.majorSemiAxis,this.m_b=a.minorSemiAxis,this.m_eSquared=a.e2,this.m_curveType===2)return this.executeClippedPolygonGreatEllipticArea(t);{const s={stack:[],error:void 0,hasError:!1};try{const _=he.unit(9101),r=this.m_inputGCS.getPECoordSys(),l=j(s,r.cloneAlterUnits(_),!1);let m,o,h=this.executeClippedPolygonGeodeticArea(t,l,0),p=0;do p++,m=this.executeClippedPolygonGeodeticArea(t,l,p),o=Math.abs(m-h),h=m;while(Math.abs(m)>1&&o>1e-8*Math.abs(m)&&p<7);return m}catch(_){s.error=_,s.hasError=!0}finally{oe(s)}}}executeClippedPolygonGeodeticArea(e,t,n){const i={stack:[],error:void 0,hasError:!1};try{const a=new G;e.queryEnvelope(a);const s=j(i,this.getEqualAreaPCSInstance(t,a),!1),_=e.clone();Ue(s,_);const r=50,l=_.getImpl().getAttributeStreamRef(0),m=e.getImpl().getAttributeStreamRef(0),o=j(i,new me,!1),h=j(i,new me,!1),p=40,c=[0,0],g=Ie(ge,p),d=Ye(p,-1),f=ge(),S=ge();let E,P;const M=s;let C=_.calculateArea2D();const T=new V(0),k=.5*Math.PI,O=1e-10*Math.abs(C)+1e-6,J=e.getPathCount();let v,$,w,A;const q=new x,b=new x,L=new x,U=new x,Y=new x,z=new x;let H,_e;for($=e.getPathStart(0),v=0;v<J;v++,$=w)for(w=e.getPathEnd(v),l.queryPoint2D(w-1<<1,L),m.queryPoint2D(w-1<<1,q),Math.abs(q.y)>k&&(q.y=W(k,q.y)),A=$;A<w;A++,L.assign(U),q.assign(b)){if(l.queryPoint2D(A<<1,U),m.queryPoint2D(A<<1,b),Math.abs(b.y)>k&&(b.y=W(k,b.y)),H=x.distance(L,U),H<r||q.y===0&&b.y===0)continue;le.geodeticDistance(this.m_a,this.m_eSquared,q.x,q.y,b.x,b.y,o,h,null,this.m_curveType);const $e=o.val,ze=h.val;for(f.setValues(0,L),S.setValues(1,U),P=n,g[0].assign(S),d[0]=n,E=0;E>=0;){_e=.5*(f.m_factor+S.m_factor),le.geodeticCoordinate(this.m_a,this.m_eSquared,q.x,q.y,$e*_e,ze,o,h,this.m_curveType),Y.x=o.val,Y.y=h.val,c[0]=Y.x,c[1]=Y.y,Q.geogToProj(M,1,c),z.x=c[0],z.y=c[1];const Ge=-z.offset(f.m_p_PCS,S.m_p_PCS),Z=.5*Ge*x.distance(f.m_p_PCS,S.m_p_PCS);if(T.pe(Z),Math.abs(Z)>O||Math.abs(Z)>0&&P>0)S.setValues(_e,z),E++,g[E].assign(S),Math.abs(Z)<=O?(P--,d[E-1]=P,d[E]=P):(P=d[E-1],d[E]=P);else{if(E<=0)break;f.assign(S),E--,S.assign(g[E]),P=d[E]}}}return C+=T.getResult(),Math.abs(C)}catch(a){i.error=a,i.hasError=!0}finally{oe(i)}}executeClippedPolygonGreatEllipticArea(e){const t=[],n=[],i=new x,a=new x,s=R(1,this.m_eSquared,new x(0,.5*Math.PI)),_=new V(0),r=new V(0),l=new V(0),m=new y,o=new y,h=new G;e.queryLooseEnvelope(h);let p=0;h.containsCoords(h.xmin,0)||(p=Math.abs(h.ymin)<Math.abs(h.ymax)?h.ymin:h.ymax);const c=new rt(this.m_eSquared,m,o,p),g=this.m_a*this.m_a,d=e.getImpl().querySegmentIterator();for(d.stripAttributes();d.nextPath();)for(;d.hasNextSegment();){const f=d.nextSegment();i.assign(f.getStartXY()),a.assign(f.getEndXY()),a.x-i.x>Math.PI?i.x+=2*Math.PI:a.x-i.x<-Math.PI&&(a.x+=2*Math.PI),this.splitSegmentCrossingItegralThreshold(f,t,n);for(let S of t)m.assign(R(this.m_a,this.m_eSquared,S.getStartXY())),o.assign(R(this.m_a,this.m_eSquared,S.getEndXY())),c.setSegmentEndPoints(m,o),this.adaptiveIntegrationWithRomberg(c,_);for(let S of n){let E=S.getStartXY(),P=S.getEndXY(),M=p;E.y<0&&(P=Xe(E,E=P),E.y=-E.y,P.y=-P.y,M=-M);const C=R(1,this.m_eSquared,E),T=R(1,this.m_eSquared,P),k=Math.min(E.y,P.y),O=Te(this.m_eSquared,E.x,P.x,M,k);r.pe(O);const J=Math.abs(Te(this.m_eSquared,E.x,P.x,k,D)),v=new y;v.setSub(C,s);const $=new y;$.setSub(T,s);const w=new y;w.setCrossProductVector(v,$);let A=g*(J-.5*w.length());A=W(A,P.x-E.x),l.pe(A)}t.length=0,n.length=0}return l.getResult()+g*(.5*(1-this.m_eSquared)*_.getResult()+r.getResult())}getEqualAreaPCSInstance(e,t){const n=t.getCenterX(),i=0,a=0;let s,_;const r=t.height();let l,m;(l=t.ymin>45*Math.PI/180||t.ymax<45*-Math.PI/180)?s=W(.5*Math.PI,t.getCenterY()):(s=t.getCenterY(),_=t.ymin+r*(2/3));const o=Ce("EqualAreaPCS"),h=e.toString();return m=l?he.fromString(I.PE_TYPE_PROJCS,`PROJCS["${o}", ${h}, PROJECTION["Lambert_Azimuthal_Equal_Area"],PARAMETER["False_Easting",${i}],PARAMETER["False_Northing", ${a}],PARAMETER["Central_Meridian", ${n}], PARAMETER["Latitude_of_Origin", ${s}], UNIT["Meter",1.0]]`):he.fromString(I.PE_TYPE_PROJCS,`PROJCS["${o}", ${h}, PROJECTION["Cylindrical_Equal_Area"],PARAMETER["False_Easting", ${i}],PARAMETER["False_Northing", ${a}],PARAMETER["Central_Meridian", ${n}],PARAMETER["Standard_Parallel_1", ${_}],PARAMETER["Latitude_of_Origin", ${s}],UNIT["Meter",1.0]]`),m}splitSegmentCrossingItegralThreshold(e,t,n){const _=R(this.m_a,this.m_eSquared,new x(0,D)),r=R(this.m_a,this.m_eSquared,new x(0,-D)),l=this.splitSegmentPassingThroughPole(e);for(let m of l){const o=m.getStartXY(),h=m.getEndXY(),p=R(this.m_a,this.m_eSquared,o),c=R(this.m_a,this.m_eSquared,h),g=new x,d=new y;let f=y.sqrDistance(_,p),S=y.sqrDistance(p,c);if(f<=100){if(!(S>400)){n.push(new N({start:o,end:h}));continue}d.assign(c.sub(p)),d.normalizeThis(),d.assign(p.add(d.mul(20))),g.assign(X(this.m_a,this.m_eSquared,d)),n.push(new N({start:o,end:g})),o.assign(g)}if(p.assign(R(this.m_a,this.m_eSquared,o)),f=y.sqrDistance(_,c),S=y.sqrDistance(p,c),f<=100){if(!(S>400)){n.push(new N({start:o,end:h}));continue}d.assign(c.sub(p)),d.normalizeThis(),d.assign(c.sub(d.mul(20))),g.assign(X(this.m_a,this.m_eSquared,d)),n.push(new N({start:g,end:h})),h.assign(g)}if(p.assign(R(this.m_a,this.m_eSquared,o)),c.assign(R(this.m_a,this.m_eSquared,h)),f=y.sqrDistance(r,p),S=y.sqrDistance(p,c),f<=100){if(!(S>400)){n.push(new N({start:o,end:h}));continue}d.assign(c.sub(p)),d.normalizeThis(),d.assign(p.add(d.mul(20))),g.assign(X(this.m_a,this.m_eSquared,d)),n.push(new N({start:o,end:g})),o.assign(g)}if(p.assign(R(this.m_a,this.m_eSquared,o)),c.assign(R(this.m_a,this.m_eSquared,h)),f=y.sqrDistance(r,c),S=y.sqrDistance(p,c),f<=100){if(!(S>400)){n.push(new N({start:o,end:h}));continue}d.assign(c.sub(p)),d.normalizeThis(),d.assign(c.sub(d.mul(20))),g.assign(X(this.m_a,this.m_eSquared,d)),n.push(new N({start:g,end:h})),h.assign(g)}t.push(new N({start:o,end:h}))}}splitSegmentPassingThroughPole(e){const t={stack:[],error:void 0,hasError:!1};try{const n=[],i=new y,a=new y,s=new y,_=new x,r=20,l=3.124139361,m=10,o=e.getStartXY(),h=e.getEndXY(),p=j(t,new me,!1);if(le.geodeticDistance(this.m_a,this.m_eSquared,o.x,o.y,h.x,h.y,p,null,null,2),Math.abs(h.x-o.x)>l&&p.val>r){const c=new He(new x(0,90),o.divide(this.m_rpu),h.divide(this.m_rpu),this.m_inputGCS,2,2);let g=we(c.makeFunctor(),0,1,1e-10);if(g.second<=m&&g.first>0&&g.first<1)return i.assign(R(this.m_a,this.m_eSquared,o)),a.assign(R(this.m_a,this.m_eSquared,h)),Ne(i,a,g.first,s),_.assign(X(this.m_a,this.m_eSquared,s)),n.push(new N({start:o,end:_})),n.push(new N({start:_,end:h})),n;if(c.setPointDistFrom(new x(0,-90)),g=we(c.makeFunctor(),0,1,1e-10),g.second<=m&&g.first>0&&g.first<1)return i.assign(R(this.m_a,this.m_eSquared,o)),a.assign(R(this.m_a,this.m_eSquared,h)),Ne(i,a,g.first,s),_.assign(X(this.m_a,this.m_eSquared,s)),n.push(new N({start:o,end:_})),n.push(new N({start:_,end:h})),n}return n.push(new N({start:o,end:h})),n}catch(n){t.error=n,t.hasError=!0}finally{oe(t)}}adaptiveIntegrationWithRomberg(e,t){const n=e.makeFunctor();let i=0,a=1,s=n(i),_=n(a);const r=1e-17,l=1e-14;let m=(i+a)/2,o=n(m),h=Math.abs(o-s),p=Math.abs(_-o),c=0;for(;c++<32&&(h/p<.1||p/h<.1);)h<p?(t.pe(te(5,i,m,l,r,n)),i=m,s=o):(t.pe(te(5,m,a,l,r,n)),a=m,_=o),m=(i+a)/2,o=Math.abs(n(m)),h=Math.abs(o-s),p=Math.abs(_-o);t.pe(te(5,i,a,l,r,n))}loxodromeAreaHemi(e,t,n,i,a){const s=n.clone(),_=a.clone();let r,l,m,o,h,p,c,g,d,f,S,E,P,M,C,T;return s.make_negative&&s.changeSign(),_.make_negative&&_.changeSign(),S=i-t,Math.abs(s.sin_phi)===1||Math.abs(_.sin_phi)===1?e.half_qp*S:s.sin_phi===_.sin_phi?(f=.5*e.one_m_e_2*s.sin_phi*(1/s.one_m_e_2_sin_2_phi+B(e.e*s.sin_phi))*S,f):(C=Math.log(_.sin_half_phi_pf*s.sin_half_phi_pz/(_.sin_half_phi_pz*s.sin_half_phi_pf)),T=Math.log(_.sin_half_asin_e_sin_phi_pf*s.sin_half_asin_e_sin_phi_pz/(_.sin_half_asin_e_sin_phi_pz*s.sin_half_asin_e_sin_phi_pf)),this.m_eSquared===1?(h=0,r=.5*(C+_.sin_phi/_.one_m_e_2_sin_2_phi-s.sin_phi/s.one_m_e_2_sin_2_phi),l=0):(h=-2*e.atanh_e_over_e*(Math.log(_.one_p_sin_phi/s.one_p_sin_phi)-e.e*T),r=(C-e.e*T)/e.one_m_e_2,l=(Math.log(_.one_m_e_2_sin_2_phi/s.one_m_e_2_sin_2_phi)+h/e.atanh_e_over_e)/e.one_m_e_2),m=-T*(s.atanh_esin_phi+_.atanh_esin_phi),o=1/s.one_m_e_2_sin_2_phi-1/_.one_m_e_2_sin_2_phi,p=F(_.one_m_sin_phi/e.one_p_e,e.e)-F(s.one_m_sin_phi/e.one_p_e,e.e),c=F(_.one_p_sin_phi/e.one_p_e,e.e)-F(s.one_p_sin_phi/e.one_p_e,e.e),g=F(s.one_m_sin_phi/-e.one_m_e,e.e)-F(_.one_m_sin_phi/-e.one_m_e,e.e),d=F(s.one_p_sin_phi/-e.one_m_e,e.e)-F(_.one_p_sin_phi/-e.one_m_e,e.e),f=.25/r*(l+m+o+h+.5*(p+c+g+d)),f+=e.half_qp,E=.5*e.one_m_e_2*s.sin_phi*(1/s.one_m_e_2_sin_2_phi+B(e.e*s.sin_phi)),P=.5*e.one_m_e_2*_.sin_phi*(1/_.one_m_e_2_sin_2_phi+B(e.e*_.sin_phi)),P<E&&(M=E,E=P,P=M),f<E&&(f=E),f>P&&(f=P),f*=S,f)}loxodromeArea(e){const t=Math.PI/180;let n=0;const i=ht(),a=fe(),s=fe();i.e=Math.sqrt(this.m_eSquared),i.one_p_e=1+i.e,i.one_m_e=1-i.e,i.one_m_e_2=1-this.m_eSquared,i.atanh_e_over_e=B(i.e),this.m_eSquared>=1?i.half_qp=1:i.half_qp=.5*(1+i.atanh_e_over_e*i.one_m_e_2),i.f=.25*Math.PI,i.z=.75*Math.PI,s.initialize(0,i.e,i.f,i.z);const _=e.getPathCount(),r=new x,l=new x,m=e.getImpl().getAttributeStreamRef(0);for(let o=0;o<_;o++){const h=e.getPathStart(o),p=e.getPathEnd(o);if(!(p-h<=1)){m.queryPoint2D(2*(p-1),r);for(let c=h;c<p;c++){m.queryPoint2D(2*c,l);const g=r.y*t,d=l.y*t;if(c===h?(a.initialize(g,i.e,i.f,i.z),a.make_negative=!1):a.assign(s),s.initialize(d,i.e,i.f,i.z),s.make_negative=!1,r.y*l.y<0){if(r.y>=90&&l.y<=-90||l.y>=90&&r.y<=-90)return Number.NaN;const f=fe();f.initialize(0,i.e,i.f,i.z),f.make_negative=!1;const S=a.atanh_sin_phi-i.e*a.atanh_esin_phi,E=s.atanh_sin_phi-i.e*s.atanh_esin_phi,P=(E*r.x-S*l.x)/(E-S);g<0?(a.make_negative=!0,n-=this.loxodromeAreaHemi(i,r.x*t,a,P*t,f),a.make_negative=!1,n+=this.loxodromeAreaHemi(i,P*t,f,l.x*t,s)):(n+=this.loxodromeAreaHemi(i,r.x*t,a,P*t,f),s.make_negative=!0,n-=this.loxodromeAreaHemi(i,P*t,f,l.x*t,s),s.make_negative=!1)}else r.y>=0?n+=this.loxodromeAreaHemi(i,r.x*t,a,l.x*t,s):(a.make_negative=!0,s.make_negative=!0,n-=this.loxodromeAreaHemi(i,r.x*t,a,l.x*t,s),a.make_negative=!1,s.make_negative=!1);r.assign(l)}}}return this.m_a*n*this.m_a}calculate(e){if(e.isEmpty()||e.getDimension()<2)return 0;if(e.getGeometryType()===xe.enumEnvelope){const t=new ye;return t.addEnvelope(e,!1),this.calculate(t)}return this.m_inputSR!==this.m_inputGCS&&this.m_transformPCS2GCS===null&&(this.m_transformPCS2GCS=ae(this.m_inputSR,this.m_inputGCS,null)),this.executePolygonGeodeticArea(e)}}class dt{getOperatorType(){return 10311}supportsCurves(){return!0}accelerateGeometry(e,t,n){return!1}canAccelerateGeometry(e){return!1}execute(e,t,n,i){return ve(e),n===4?new it().execute(e,t,i):new pt(t,n,i).calculate(e)}}export{dt as OperatorGeodeticArea};
