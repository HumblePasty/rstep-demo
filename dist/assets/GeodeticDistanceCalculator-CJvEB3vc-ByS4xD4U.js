import{lr as lt,kT as h,ls as it,kQ as p,kL as k,k_ as st,kO as ct,l2 as U,kS as _t,fz as L,fB as B,l6 as w,la as M,fC as q,kY as R,kR as C,lt as j,k$ as S,lb as Q,lu as dt,lv as E,lh as F,ln as pt,lw as gt,kM as xt,lx as yt,l0 as nt,l1 as Pt,ly as St,kU as ft,kX as Z,lz as ot,lA as J,lB as at,lg as ht,lC as Y,lD as Dt}from"./index-BlU5-B7d.js";import{o as Gt}from"./OperatorShapePreservingDensify-CmTdM5it.js";function mt(){return{outPoint:new p,index:-1,t:Number.NaN}}function V(d,e,t,i){d.outPoint.assign(e),d.index=t,d.t=i}function vt(d,e,t,i,s,n){if(d.getGeometryType()===h.enumPolygon){for(;i.nextPath();)if(i.hasNextSegment()){const o=i.nextSegment();if(it(d,o.getEndXY(),0)!==0)return V(s,o.getEndXY(),-1,Number.NaN),V(n,o.getEndXY(),-1,Number.NaN),!0}i.resetToFirstPath()}if(e.getGeometryType()===h.enumPolygon){for(;t.nextPath();)if(t.hasNextSegment()){const o=t.nextSegment();if(it(e,o.getEndXY(),0)!==0)return V(s,o.getEndXY(),-1,Number.NaN),V(n,o.getEndXY(),-1,Number.NaN),!0}t.resetToFirstPath()}return!1}function Tt(d){const e=d.getPathCount(),t=new Array(d.getSegmentCount());let i=0;for(let s=0;s<e;++s){const n=i+d.getSegmentCountPath(s);for(let o=i,a=d.getPathStart(s);o<n;++o,++a)t[o]=a;i=n}return lt(d.getPointCount(),t),t}function bt(){return new k}class wt{[Symbol.dispose](){this.m_peR1.destroy(),this.m_peR2.destroy(),this.m_peR3.destroy(),this.m_peR1=null,this.m_peR2=null,this.m_peR3=null}constructor(e,t,i){this.m_peR1=new w,this.m_peR2=new w,this.m_peR3=new w,e!==void 0?this.reset(e,t,i):this.reset(1,0,1)}reset(e,t,i){this.m_a=e,this.m_e2=t,this.m_b=this.m_a*Math.sqrt(1-this.m_e2),this.m_unitToDegree=i,this.m_unitToRad=.017453292519943295*i,this.m_u180=180/this.m_unitToDegree,this.m_u360=360/this.m_unitToDegree}calculateBbox(e,t,i,s){const n=this.m_peR1,o=this.m_peR2,a=this.m_peR3;M.geodeticDistance(this.m_a,this.m_e2,e*this.m_unitToRad,t*this.m_unitToRad,i*this.m_unitToRad,s*this.m_unitToRad,a,n,o,0);const m=Math.cos(n.val),r=Math.cos(o.val+3.141592653589793),u=t*this.m_unitToRad,c=Y.phiToEta(this.m_e2,u),l=Math.sin(n.val)*Math.cos(c);let x=t;if(m*r<0){const v=m<0?-1:1,D=Math.acos(Math.abs(l))*v;x=Y.etaToPhi(this.m_e2,D)/this.m_unitToRad}let g=Dt((i-e)*this.m_unitToRad,2*Math.PI);Math.abs(g)>Math.PI&&(g=g>0?g-2*Math.PI:g+2*Math.PI),g/=this.m_unitToRad,i=e+g;const _=bt();return _.xmin=Math.min(e,i),_.xmax=Math.max(e,i),_.ymin=Math.min(t,s),_.ymin=Math.min(_.ymin,x),_.ymax=Math.max(t,s),_.ymax=Math.max(_.ymax,x),_}minDistanceGeodesic(e,t){const i=rt(e),s=rt(t);if(i&&s)return this.lowerDistanceGeodetic_(e.xmin,e.ymin,t.xmin,t.ymin);const n=this.normalizeGeodesic_(t,e);return Mt(e,n)?e.ymin>=n.ymax?this.minDistanceGeodesicUpDown_(e,n):n.ymin>=e.ymax?this.minDistanceGeodesicUpDown_(n,e):e.xmin>n.xmax?this.minDistanceGeodesicLeftRight_(n,e):this.minDistanceGeodesicLeftRight_(e,n):0}sqrMaxMinDistanceGeodesic(e,t){return S(0),0}maxDistanceGeodesic(e,t){return S(0),0}sqrMinDistance(e,t){return S(0),0}sqrMaxDistance(e,t){return S(0),0}sqrMaxMinDistance(e,t){return S(0),0}calculateMaxDim(e){return S(0),0}lowerDistanceGeodesic(e,t,i,s){return S(0),0}upperDistanceGeodesic(e,t,i,s){return S(0),0}normalizeGeodesic_(e,t){const i=e.clone(),s=e.clone();let n=K(i,t);if(n===0)return i;for(;s.xmax>t.xmin;){s.xmin-=this.m_u360,s.xmax-=this.m_u360;const o=K(s,t);if(o<n&&(i.assign(s),n=o,n===0))return i}for(s.assign(e);s.xmin<t.xmax;){s.xmin+=this.m_u360,s.xmax+=this.m_u360;const o=K(s,t);if(o<n&&(i.assign(s),n=o,n===0))return i}return i}lowerDistanceGeodetic_(e,t,i,s){const n=this.m_peR1;{const o=this.m_b*this.m_b/this.m_a,a=Y.phiToPhig(this.m_e2,this.m_unitToRad*t),m=Y.phiToPhig(this.m_e2,this.m_unitToRad*s);M.geodeticDistance(o,0,this.m_unitToRad*e,a,this.m_unitToRad*i,m,n,null,null,0)}return n.val}upperDistanceGeodetic_(e,t,i,s){return S(0),0}minDistanceGeodesicUpDown_(e,t){if(t.xmin<=e.xmin?t.xmax>=e.xmin:e.xmax>=t.xmin)return this.lowerDistanceGeodetic_(0,e.ymin,0,t.ymax);if(t.xmin>e.xmax){const i=this.lowerDistanceGeodeticSegMeridional_(e.xmax,e.ymin,e.ymax,t.xmin,t.ymin,t.ymax);if(t.xmax-e.xmin<this.m_u180)return i;const s=this.lowerDistanceGeodeticSegMeridional_(e.xmin,e.ymin,e.ymax,t.xmax,t.ymin,t.ymax);return Math.min(i,s)}{const i=this.lowerDistanceGeodeticSegMeridional_(e.xmin,e.ymin,e.ymax,t.xmax,t.ymin,t.ymax);if(e.xmax-t.xmin<this.m_u180)return i;const s=this.lowerDistanceGeodeticSegMeridional_(e.xmax,e.ymin,e.ymax,t.xmin,t.ymin,t.ymax);return Math.min(i,s)}}minDistanceGeodesicLeftRight_(e,t){let i=Math.abs(e.xmax-t.xmin);for(;i>this.m_u180;)i-=this.m_u360;let s=Math.abs(e.xmin-t.xmax);for(;s>this.m_u180;)s-=this.m_u360;return Math.abs(i)<=Math.abs(s)?this.minDistanceGeodesicLeftRightNormalized_(e,t):this.minDistanceGeodesicLeftRightNormalized_(t,e)}minDistanceGeodesicLeftRightNormalized_(e,t){let i,s;return i=this.lowerDistanceGeodetic_(e.xmax,e.ymin,t.xmin,t.ymin),e.ymin>=t.ymin&&e.ymin<=t.ymax&&(s=this.lowerDistanceGeodeticPtMeridional_(e.xmax,e.ymin,t.xmin,t.ymin,t.ymax),i=Math.min(i,s)),t.ymin>=e.ymin&&t.ymin<=e.ymax&&(s=this.lowerDistanceGeodeticPtMeridional_(t.xmin,t.ymin,e.xmax,e.ymin,e.ymax),i=Math.min(i,s)),s=this.lowerDistanceGeodetic_(e.xmax,e.ymax,t.xmin,t.ymax),i=Math.min(i,s),e.ymax>=t.ymin&&e.ymax<=t.ymax&&(s=this.lowerDistanceGeodeticPtMeridional_(e.xmax,e.ymax,t.xmin,t.ymin,t.ymax),i=Math.min(i,s)),t.ymax>=e.ymin&&t.ymax<=e.ymax&&(s=this.lowerDistanceGeodeticPtMeridional_(t.xmin,t.ymax,e.xmax,e.ymin,e.ymax),i=Math.min(i,s)),i}normalizeDistance_(e){return S(0),0}lowerDistanceGeodeticSegMeridional_(e,t,i,s,n,o){let a=this.lowerDistanceGeodeticPtMeridional_(e,t,s,n,o);const m=this.lowerDistanceGeodeticPtMeridional_(e,i,s,n,o);let r=this.lowerDistanceGeodeticPtMeridional_(s,n,e,t,i);const u=this.lowerDistanceGeodeticPtMeridional_(s,o,e,t,i);return a=Math.min(a,m),r=Math.min(r,u),Math.min(a,r)}minDistanceGeodesicPointBox_(e,t,i){return S(0),0}lowerDistanceGeodeticPtMeridional_(e,t,i,s,n){const o=this.m_b*this.m_b/this.m_a,a=Y.phiToPhig(this.m_e2,this.m_unitToRad*t),m=Y.phiToPhig(this.m_e2,this.m_unitToRad*s),r=Y.phiToPhig(this.m_e2,this.m_unitToRad*n),u=this.m_peR1,c=this.m_peR2;M.geodeticDistance(o,0,this.m_unitToRad*i,m,this.m_unitToRad*e,a,u,null,null,0),M.geodeticDistance(o,0,this.m_unitToRad*i,r,this.m_unitToRad*e,a,c,null,null,0);const l=R(1,0,new p(this.m_unitToRad*e,a)),x=R(1,0,new p(this.m_unitToRad*i,m)),g=R(1,0,new p(this.m_unitToRad*i,r));let _=new C;_.setCrossProductVector(x,g);const v=x.dotProduct(g);if(_.length()<1568e-13)return v>=0?Math.min(u.val,c.val):0;_=_.getUnitVector();let D=new C;if(D.setCrossProductVector(_,l),D.length()<1568e-13)return Math.min(u.val,c.val)-1e-5*o;D=D.getUnitVector();let y=l.sub(_.mul(l.dotProduct(_)));{const f=new C;f.setCrossProductVector(x,y);const T=new C;T.setCrossProductVector(y,g);let P=_.dotProduct(f)>0&&_.dotProduct(T)>0;if(P||(y.negateThis(),f.setCrossProductVector(x,y),T.setCrossProductVector(y,g),P=_.dotProduct(f)>0&&_.dotProduct(T)>0),P){y=y.getUnitVector();const O=ht(1,0,y),X=this.m_peR3;M.geodeticDistance(o,0,this.m_unitToRad*e,a,O.x,O.y,X,null,null,0);const N=Math.min(u.val,c.val);return Math.min(N,X.val)}}return Math.min(u.val,c.val)}fixAngle(e){return S(0),0}moveCloser(e,t){return S(0),0}}function rt(d){return d.xmin===d.xmax&&d.ymin===d.ymax}function Mt(d,e){return e.xmax<d.xmin||e.xmin>d.xmax||e.ymax<d.ymin||e.ymin>d.ymax}function K(d,e){let t,i=0;return t=d.xmin-e.xmax,t>i&&(i=t),t=e.xmin-d.xmax,t>i&&(i=t),i}class Et{}function ut(d){return{outPoint:d===void 0?new p:d.clone()}}function z(d,e){d.outPoint.assign(e.outPoint)}function b(){return new k}class Rt{constructor(e,t,i,s,n=0,o=4){this.m_ptDistFrom=new p,this.m_segStartPt=new p,this.m_segEndPt=new p,this.m_geodeticLength=new w,this.m_az12=new w,this.m_minGeodeticDist=new w,this.m_segStartPt3d=new C,this.m_segEndPt3d=new C,this.m_sr=s,this.m_distCurveType=n,this.m_segCurveType=o,this.m_inputGCS=this.m_sr.getGCS(),this.m_rpu=this.m_inputGCS.getUnit().getUnitToBaseFactor(),this.m_bIsPannablePcs=this.m_sr.getCoordinateSystemType()===2&&this.m_sr.isPannable();const a=ct();this.m_inputGCS.querySpheroidData(a),this.m_a=a.majorSemiAxis,this.m_eSquared=a.e2,this.setPointDistFrom(e),this.setSegmentEndPoints(t,i)}setSegmentEndPoints(e,t){this.m_segStartPt.assign(e),this.m_segEndPt.assign(t),this.m_bIsPannablePcs||(this.m_segStartPt.mulThis(this.m_rpu),this.m_segEndPt.mulThis(this.m_rpu)),this.m_segCurveType===2&&(this.m_segStartPt3d.assign(R(this.m_a,this.m_eSquared,this.m_segStartPt)),this.m_segEndPt3d.assign(R(this.m_a,this.m_eSquared,this.m_segEndPt))),this.calculateAndUpdateSegmentLength()}setPointDistFrom(e){this.m_ptDistFrom.assign(e),this.m_ptDistFrom.scale(this.m_rpu)}setSegmentCurveType(e){this.m_segCurveType=e}setDistanceCurveType(e){this.m_distCurveType=e}makeFunctor(){return e=>{let t;switch(this.m_segCurveType){case 0:case 1:case 3:{const i={stack:[],error:void 0,hasError:!1};try{const s=B(i,new w,!1),n=B(i,new w,!1);M.geodeticCoordinate(this.m_a,this.m_eSquared,this.m_segStartPt.x,this.m_segStartPt.y,this.m_geodeticLength.val*e,this.m_az12.val,s,n,this.m_segCurveType),t=new p(s.val,n.val);break}catch(s){i.error=s,i.hasError=!0}finally{q(i)}}case 2:{const i=C.lerp(this.m_segStartPt3d,this.m_segEndPt3d,e);t=ht(this.m_a,this.m_eSquared,i);break}case 4:t=p.lerp(this.m_segStartPt,this.m_segEndPt,e),this.m_bIsPannablePcs&&(E(this.m_sr,0,[t],1),t.mulThis(this.m_rpu));break;default:Z("Invalid curve type")}return M.geodeticDistance(this.m_a,this.m_eSquared,this.m_ptDistFrom.x,this.m_ptDistFrom.y,t.x,t.y,this.m_minGeodeticDist,null,null,this.m_distCurveType),this.m_minGeodeticDist.val}}calculateAndUpdateSegmentLength(){switch(this.m_segCurveType){case 0:case 2:case 1:case 3:M.geodeticDistance(this.m_a,this.m_eSquared,this.m_segStartPt.x,this.m_segStartPt.y,this.m_segEndPt.x,this.m_segEndPt.y,this.m_geodeticLength,this.m_az12,null,this.m_segCurveType);break;case 4:this.m_geodeticLength.val=p.distance(this.m_segStartPt,this.m_segEndPt);break;default:Z("Invalid curve type")}}[Symbol.dispose](){this.m_geodeticLength[Symbol.dispose](),this.m_az12[Symbol.dispose](),this.m_minGeodeticDist[Symbol.dispose]()}}function W(){return new Et}class Bt{[Symbol.dispose](){this.m_envHelper[Symbol.dispose]()}constructor(e,t,i,s,n){this.m_boxGeomA=b(),this.m_boxGeomB=b(),this.m_envGeomA=new k,this.m_envGeomB=new k,this.m_progressCounter=0,this.m_transformPCS2GCS=null,this.m_segmentBoxesA=new Map,this.m_segmentBoxesB=new Map,this.m_boundaryPtsA=[],this.m_boundaryPtsB=[],this.m_scaleToRadians=new st,this.m_scaleToDegrees=new st,this.m_inputSR=e,this.m_distCurveType=t,this.m_progressTracker=i,this.m_maxDistance=s,this.m_maxDeviation=n,this.m_inputGCS=e.getGCS(),this.m_peGeogcs=this.m_inputGCS.getPECoordSys(),this.m_tolerance=0;const o=ct();this.m_inputGCS.querySpheroidData(o),this.m_a=o.majorSemiAxis,this.m_eSquared=o.e2,this.m_rpu=this.m_inputGCS.getUnit().getUnitToBaseFactor(),this.m_envHelper=new wt(this.m_a,this.m_eSquared,1),this.m_distCurveType===4&&(this.m_distCurveType=0),this.m_boxGeomA.setEmpty(),this.m_boxGeomB.setEmpty(),this.m_envGeomA.setEmpty(),this.m_envGeomB.setEmpty(),this.m_bIsPannablePcs=this.m_inputSR.getCoordinateSystemType()===2&&this.m_inputSR.isPannable()}progress(e=!1){}calculate(e,t,i,s){const n=ut(),o=ut();if(e.queryEnvelope(this.m_envGeomA),t.queryEnvelope(this.m_envGeomB),this.checkGeometriesIntersect(e,t,n,o))return i&&z(i,n),s&&z(s,o),0;const a=this.prepareGeometry(e);if(a.isEmpty())return Number.NaN;const m=this.prepareGeometry(t);if(m.isEmpty())return Number.NaN;this.m_tolerance=this.computeTolerance(a,m);const r=this._ExecuteBruteForce(a,m,n,o);return r>=this.m_maxDistance?Number.NaN:(i&&(this.prepareOutput(n),z(i,n)),s&&(this.prepareOutput(o),z(s,o)),r)}createDistanceFunctor(e,t,i){const s=new Rt(e,t,i,this.m_inputSR,this.m_distCurveType);return this.m_bIsPannablePcs||this.m_inputSR.getCoordinateSystemType()===1||s.setSegmentCurveType(2),s}_NormalizeAndProject(e){if(this.m_inputSR.isPannable()&&(e=new U().foldInto360Range(e,this.m_inputSR)),this.m_inputSR.getCoordinateSystemType()===2){const t=_t(this.m_inputSR,this.m_inputGCS,null);e=new U().execute(e,t,this.m_progressTracker)}return e}_ExecuteBruteForce(e,t,i,s){switch(e.getGeometryType()){case h.enumPoint:return this.calculateDistanceGeodeticPointGeometry(e,t,i,s);case h.enumMultiPoint:return this.calculateDistanceGeodeticMultipointGeometry(e,t,i,s);case h.enumPolyline:case h.enumPolygon:case h.enumEnvelope:return this.calculateDistanceGeodeticMultipathGeometry(e,t,i,s);default:L("")}}calculateDistanceGeodeticPointGeometry(e,t,i,s){switch(t.getGeometryType()){case h.enumPoint:return this.calculateDistanceGeodeticPointPoint(e,t,i,s);case h.enumMultiPoint:return this.calculateDistanceGeodeticPointMultipoint(e,t,i,s);case h.enumPolyline:case h.enumPolygon:return this.calculateDistanceGeodeticPointMultipath(e,t,i,s);default:L("")}}calculateDistanceGeodeticPointPoint(e,t,i,s){const n={stack:[],error:void 0,hasError:!1};try{const o=e.getXY();o.scale(this.m_rpu);const a=t.getXY();a.scale(this.m_rpu),i.outPoint.assign(o),s.outPoint.assign(a);const m=B(n,new w,!1);return M.geodeticDistance(this.m_a,this.m_eSquared,o.x,o.y,a.x,a.y,m,null,null,this.m_distCurveType),m.val}catch(o){n.error=o,n.hasError=!0}finally{q(n)}}calculateDistanceGeodeticPointMultipoint(e,t,i,s){const n={stack:[],error:void 0,hasError:!1};try{this.computeEnvelopesAndBoxes(e,t);const o=this.estimateMinimumDistance(i,s);let a=o<this.m_maxDistance?o:this.m_maxDistance;const m=e.getXY();m.scale(this.m_rpu),i.outPoint.assign(m);const r=R(this.m_a,this.m_eSquared,m),u=new p,c=t.getImpl(),l=B(n,new w,!1),x=c.getPointCount();for(let g=0;g<x;++g){c.queryXY(g,u),u.scale(this.m_rpu);const _=R(this.m_a,this.m_eSquared,u);if(!(C.distance(r,_)>a)&&!(this.m_envHelper.minDistanceGeodesic(this.m_boxGeomA,this.m_boxGeomB)>a)&&(M.geodeticDistance(this.m_a,this.m_eSquared,m.x,m.y,u.x,u.y,l,null,null,this.m_distCurveType),l.val<a&&(a=l.val,s.outPoint=u,a===0)))return a}return a===this.m_maxDistance?Number.POSITIVE_INFINITY:a}catch(o){n.error=o,n.hasError=!0}finally{q(n)}}calculateDistanceGeodeticPointMultipath(e,t,i,s){const n={stack:[],error:void 0,hasError:!1};try{const o=new p,a=new p;o.assign(e.getXY()),a.assign(e.getXY()),i.outPoint.assign(a.mul(this.m_rpu)),this.m_bIsPannablePcs&&j(this.m_inputSR,[o],1,!1),this.computeEnvelopesAndBoxes(e,t);const m=this.estimateMinimumDistance(i,s);let r=m<this.m_maxDistance?m:this.m_maxDistance;const u=t.getImpl(),c=new p(0,0),l=new p(0,0),x=[1],g=this.canUseSpatialTree(e,t),_=W();g&&this.buildSpatialTree(_,t);const v=b();v.setCoords({xmin:a.x,ymin:a.y,xmax:a.x,ymax:a.y});const D=B(n,this.createDistanceFunctor(a,c,l),!1),y=u.querySegmentIterator();if(y.stripAttributes(),g)S(0);else for(;y.nextPath();)for(;y.hasNextSegment();){const f=y.nextSegment(),T=this.findOrComputeBoxSegment(y.getStartPointIndex(),f,this.m_segmentBoxesB);if(this.m_envHelper.minDistanceGeodesic(v,T)>r)continue;const P=this.calculateDistanceGeodeticPointSegment(o,a,f,x,D);if(P.second<r&&(this.updateOutputSegment(s,f,P.first),r=P.second,r===0))return 0}return r===this.m_maxDistance?Number.POSITIVE_INFINITY:r}catch(o){n.error=o,n.hasError=!0}finally{q(n)}}calculateDistanceGeodeticMultipointGeometry(e,t,i,s){switch(t.getGeometryType()){case h.enumPoint:return this.calculateDistanceGeodeticPointMultipoint(t,e,s,i);case h.enumMultiPoint:return this.calculateDistanceGeodeticMultipointMultipoint(e,t,i,s);case h.enumPolyline:case h.enumPolygon:case h.enumEnvelope:return this.calculateDistanceGeodeticMultipointMultipath(e,t,i,s);default:L("")}}calculateDistanceGeodeticMultipointMultipoint(e,t,i,s){const n={stack:[],error:void 0,hasError:!1};try{const o=B(n,new w,!1);this.computeEnvelopesAndBoxes(e,t);const a=this.estimateMinimumDistance(i,s);let m=a<this.m_maxDistance?a:this.m_maxDistance;const r=new p,u=new p,c=e.getImpl(),l=t.getImpl(),x=b(),g=c.getPointCount(),_=l.getPointCount();for(let v=0;v<g;++v){if(r.assign(c.getXY(v)),x.setCoords({xmin:r.x,ymin:r.y,xmax:r.x,ymax:r.y}),this.m_envHelper.minDistanceGeodesic(x,this.m_boxGeomB)>m)continue;r.scale(this.m_rpu);const D=R(this.m_a,this.m_eSquared,r);for(let y=0;y<_;++y){u.assign(l.getXY(y)),u.scale(this.m_rpu);const f=R(this.m_a,this.m_eSquared,u);if(!(C.distance(D,f)>=m)&&(M.geodeticDistance(this.m_a,this.m_eSquared,r.x,r.y,u.x,u.y,o,null,null,this.m_distCurveType),o.val<m&&(i.outPoint.assign(r),s.outPoint.assign(u),m=o.val,m===0)))return m}}return m===this.m_maxDistance?Number.POSITIVE_INFINITY:m}catch(o){n.error=o,n.hasError=!0}finally{q(n)}}calculateDistanceGeodeticMultipointMultipath(e,t,i,s){const n={stack:[],error:void 0,hasError:!1};try{const o=t.getImpl().querySegmentIterator();o.stripAttributes(),this.computeEnvelopesAndBoxes(e,t);const a=this.estimateMinimumDistance(i,s);let m=a<this.m_maxDistance?a:this.m_maxDistance;const r=new p,u=new p(0,0),c=new p(0,0),l=new p(0,0),x=[0],g=b(),_=B(n,this.createDistanceFunctor(u,c,l),!1),v=W(),D=this.canUseSpatialTree(e,t);D&&this.buildSpatialTree(v,t);const y=e.getPointCount();for(let f=0;f<y;++f)if(r.assign(e.getXY(f)),u.assign(e.getXY(f)),this.m_bIsPannablePcs&&j(this.m_inputSR,[r],1,!1),g.setCoords({xmin:u.x,ymin:u.y,xmax:u.x,ymax:u.y}),!(this.m_envHelper.minDistanceGeodesic(g,this.m_boxGeomB)>m))if(_.setPointDistFrom(u),D)S(0);else{for(;o.nextPath();)for(;o.hasNextSegment();){const T=o.nextSegment();if(this.m_envHelper.minDistanceGeodesic(g,this.findOrComputeBoxSegment(o.getStartPointIndex(),T,this.m_segmentBoxesB))>m)continue;const P=this.calculateDistanceGeodeticPointSegment(r,u,T,x,_);if(P.second<m&&(i.outPoint.assign(u.mul(this.m_rpu)),this.updateOutputSegment(s,T,P.first),m=P.second,m===0))return 0}o.resetToFirstPath()}return m===this.m_maxDistance?Number.POSITIVE_INFINITY:m}catch(o){n.error=o,n.hasError=!0}finally{q(n)}}calculateDistanceGeodeticMultipathGeometry(e,t,i,s){switch(t.getGeometryType()){case h.enumPoint:return this.calculateDistanceGeodeticPointMultipath(t,e,s,i);case h.enumMultiPoint:return this.calculateDistanceGeodeticMultipointMultipath(t,e,s,i);case h.enumPolyline:case h.enumPolygon:case h.enumEnvelope:return this.calculateDistanceGeodeticMultipathMultipath(e,t,i,s);default:L("")}}calculateDistanceGeodeticMultipathMultipath(e,t,i,s){const n=[e],o=[t],a=this.swapGeometries(n,o),m=n[0],r=o[0];this.computeEnvelopesAndBoxes(n[0],o[0]);const u=this.estimateMinimumDistance(i,s),c=this.calculateDistanceGeodeticMultipathMultipath_(m,r,i,s,u);return a&&(s.outPoint=Q(i.outPoint,i.outPoint=s.outPoint)),c}calculateDistanceGeodeticMultipathMultipath_(e,t,i,s,n=Number.MAX_VALUE){const o={stack:[],error:void 0,hasError:!1};try{let a=n;const m=new p(0,0),r=new p,u=new p(0,0),c=new p,l=new p(0,0),x=new p,g=new p,_=new p,v=[new p],D=[0],y=[0],f=b(),T=b(),P=B(o,this.createDistanceFunctor(l,m,u),!1),O=W(),X=this.canUseSpatialTree(e,t);X&&this.buildSpatialTree(O,t);const N=t.querySegmentIterator();N.stripAttributes();const $=new dt,tt=Tt(e);for(let H=0;H<tt.length;++H){const et=tt[H];e.getSegmentBuffer(et,$,!0);const I=$.get();if(f.assign(this.findOrComputeBoxSegment(et,I,this.m_segmentBoxesA)),X)S(0);else{if(l.assign(I.getStartXY()),x.assign(I.getStartXY()),g.assign(I.getEndXY()),_.assign(I.getEndXY()),this.m_bIsPannablePcs&&(E(this.m_inputSR,0,[x],1),E(this.m_inputSR,0,[_],1)),this.m_envHelper.minDistanceGeodesic(f,this.m_boxGeomB)>a)continue;for(;N.nextPath();){for(;N.hasNextSegment();){const A=N.nextSegment();if(m.assign(A.getStartXY()),r.assign(A.getStartXY()),u.assign(A.getEndXY()),c.assign(A.getEndXY()),I.intersect(A,v,D,y,this.m_tolerance))return this.updateOutputSegment(i,I,D[0]),this.updateOutputSegment(s,A,y[0]),0;if(this.m_bIsPannablePcs&&(E(this.m_inputSR,0,[r],1),E(this.m_inputSR,0,[c],1)),T.assign(this.findOrComputeBoxPoint(N.getStartPointIndex(),r,c,this.m_segmentBoxesB)),this.m_envHelper.minDistanceGeodesic(f,T)>a)continue;P.setSegmentEndPoints(m,u),P.setPointDistFrom(x);let G=F(P.makeFunctor(),0,1,1e-10);if(G.second<a&&(i.outPoint.assign(x.mul(this.m_rpu)),this.updateOutputSegment(s,A,G.first),a=G.second,a===0)||(P.setPointDistFrom(_),G=F(P.makeFunctor(),0,1,1e-10),G.second<a&&(i.outPoint.assign(_.mul(this.m_rpu)),this.updateOutputSegment(s,A,G.first),a=G.second,a===0))||(P.setSegmentEndPoints(l,g),P.setPointDistFrom(r),G=F(P.makeFunctor(),0,1,1e-10),G.second<a&&(this.updateOutputSegment(i,I,G.first),s.outPoint.assign(r.mul(this.m_rpu)),a=G.second,a===0))||(P.setPointDistFrom(c),G=F(P.makeFunctor(),0,1,1e-10),G.second<a&&(this.updateOutputSegment(i,I,G.first),s.outPoint.assign(c.mul(this.m_rpu)),a=G.second,a===0)))break}if(a===0)return 0}N.resetToFirstPath()}}return a===this.m_maxDistance?Number.POSITIVE_INFINITY:a}catch(a){o.error=a,o.hasError=!0}finally{q(o)}}calculateDistanceGeodeticPointSegment(e,t,i,s,n){const o=i.getStartXY(),a=i.getEndXY();return i.intersectPoint(e,s,this.m_tolerance)?pt(s[0],0):(n.setPointDistFrom(t),n.setSegmentEndPoints(o,a),F(n.makeFunctor(),0,1,1e-10))}prepareGeometry(e){let t=e.clone();const i=e.getGeometryType();if(i===h.enumPoint||i===h.enumMultiPoint)return this._NormalizeAndProject(t);if(i===h.enumEnvelope&&(t=this.envelopeToPolygon(t)),this.m_inputSR.isPannable())return this.prepareGeometryPannable(t,4);if(this.m_inputSR.getCoordinateSystemType()===2){if(t=gt(t,this.m_inputSR,0,null),t.isEmpty())return t;t=new Gt().execute(t,this.m_inputSR,5e4,this.m_maxDeviation/2,0,null);const o=this.m_inputSR.getSRToGCSTransform();return new U().execute(t,o,this.m_progressTracker)}const s=new k;t.queryLooseEnvelope(s);const n=this.m_inputSR.getPannableExtent();if(s.ymin<n.ymin||s.ymax>n.ymax){const o=new k(s.xmin-1,n.ymin,s.xmax+1,n.ymax);if(t=new xt().execute(t,o,this.m_inputSR,this.m_progressTracker),t.isEmpty())return t}return s.width()>2*n.width()&&(t=yt(t,-2*n.width(),2*n.width(),this.m_inputSR,!0,0,!0,this.m_progressTracker)),t}prepareGeometryPannable(e,t){const i=new k;e.queryEnvelope(i);const s=this.m_inputSR.getPannableExtent();if(s.containsEnvelope(i))return e;const n=new nt;s.queryIntervalX(n);const o=new nt;return i.queryIntervalX(o),e=n.contains(o)?Pt(e,this.m_inputSR):new U().foldInto360RangeGeodetic(e,this.m_inputSR,t)}prepareOutput(e){e.outPoint.scale(1/this.m_rpu),this.m_inputSR.getCoordinateSystemType()===2&&j(this.m_inputSR,[e.outPoint],1,!1)}updateOutputSegment(e,t,i){t.queryCoord2D(i,e.outPoint),this.m_bIsPannablePcs&&E(this.m_inputSR,0,[e.outPoint],1),e.outPoint.mulThis(this.m_rpu)}computeTolerance(e,t){e.queryEnvelope(this.m_envGeomA),t.queryEnvelope(this.m_envGeomB);const i=new k(this.m_envGeomA);return i.mergeEnvelope2D(this.m_envGeomB),St(null,i)}envelopeToPolygon(e){const t=new ft;return t.addEnvelope(e,!1),t}computeEnvelopesAndBoxes(e,t){e.queryEnvelope(this.m_envGeomA),t.queryEnvelope(this.m_envGeomB),this.m_boxGeomA=this.computeBoxGeometry(e,this.m_boundaryPtsA,this.m_segmentBoxesA),this.m_boxGeomB=this.computeBoxGeometry(t,this.m_boundaryPtsB,this.m_segmentBoxesB)}computeBoxGeometry(e,t,i){switch(e.getGeometryType()){case h.enumPoint:return this.computeBoxPoint(e,t);case h.enumMultiPoint:return this.computeBoxMultiPoint(e,t);case h.enumPolyline:case h.enumPolygon:return this.computeBoxMultiPath(e,t,i);default:Z("Invalid geometry type")}}computeBoxPoint(e,t){const i=e.getXY();t.length=1,t[0]=i.mul(this.m_rpu);const s=b();return s.setCoords({xmin:i.x,ymin:i.y,xmax:i.x,ymax:i.y}),s}computeBoxSegment(e){return S(0),{}}computeBoxMultiPoint(e,t){let i=!0;for(let n=0;n<e.getPointCount();++n){const o=e.getXY(n);if(i){t.length=4;for(let a=0;a<t.length;++a)t[a]=o.clone();i=!1}o.x<t[0].x&&t[0].assign(o),o.y>t[1].y&&t[1].assign(o),o.x>t[2].x&&t[2].assign(o),o.y<t[3].y&&t[3].assign(o)}for(let n=0;n<t.length;++n)t[n].mulThis(this.m_rpu);const s=b();return e.queryEnvelope(s),s}computeBoxMultiPath(e,t,i){let s=!0;const n=b();n.setEmpty();const o=e.querySegmentIterator();for(o.stripAttributes();o.nextPath();)for(;o.hasNextSegment();){const a=o.nextSegment(),m=a.getStartXY(),r=a.getEndXY();if(this.m_bIsPannablePcs&&(E(this.m_inputSR,0,[m],1),E(this.m_inputSR,0,[r],1)),s){t.length=4;for(let c=0;c<t.length;++c)t[c]=m.clone();s=!1}m.x<t[0].x&&t[0].assign(m),m.y>t[1].y&&t[1].assign(m),m.x>t[2].x&&t[2].assign(m),m.y<t[3].y&&t[3].assign(m),r.x<t[0].x&&t[0].assign(r),r.y>t[1].y&&t[1].assign(r),r.x>t[2].x&&t[2].assign(r),r.y<t[3].y&&t[3].assign(r);const u=this.findOrComputeBoxPoint(o.getStartPointIndex(),m,r,i);n.mergeEnvelope2D(u)}for(let a=0;a<t.length;++a)t[a].mulThis(this.m_rpu);return n}findOrComputeBoxSegment(e,t,i){if(!i.has(e)){let s=b();if(t.queryEnvelope(s),this.m_bIsPannablePcs){const n=p.construct(s.xmin,s.ymin),o=p.construct(s.xmax,s.ymax);E(this.m_inputSR,0,[n],1),E(this.m_inputSR,0,[o],1),s=this.m_envHelper.calculateBbox(n.x,n.y,o.x,o.y)}return i.set(e,s),s}return i.get(e)}findOrComputeBoxPoint(e,t,i,s){if(!s.has(e)){let n=b();return n.setCoords({xmin:t.x,ymin:t.y,xmax:i.x,ymax:i.y}),this.m_bIsPannablePcs&&(n=this.m_envHelper.calculateBbox(n.xmin,n.ymin,n.xmax,n.ymax)),s.set(e,n),n}return s.get(e)}checkPointInPolygon(e,t){return S(0),!1}estimateMinimumDistance(e,t){const i={stack:[],error:void 0,hasError:!1};try{const s=c=>R(this.m_a,this.m_eSquared,c),n=this.m_boundaryPtsA.map(s),o=this.m_boundaryPtsB.map(s);let a=Number.MAX_VALUE,m=0,r=0;for(let c=0;c<n.length;++c)for(let l=0;l<o.length;++l){const x=C.distance(n[c],o[l]);x<a&&(a=x,m=c,r=l)}e.outPoint.assign(this.m_boundaryPtsA[m]),t.outPoint.assign(this.m_boundaryPtsB[r]);const u=B(i,new w,!1);return M.geodeticDistance(this.m_a,this.m_eSquared,this.m_boundaryPtsA[m].x,this.m_boundaryPtsA[m].y,this.m_boundaryPtsB[r].x,this.m_boundaryPtsB[r].y,u,null,null,this.m_distCurveType),u.val}catch(s){i.error=s,i.hasError=!0}finally{q(i)}}swapGeometries(e,t){return ot(e[0])>ot(t[0])&&(t[0]=Q(e[0],e[0]=t[0]),this.m_envGeomB=Q(this.m_envGeomA,this.m_envGeomA=this.m_envGeomB),!0)}canUseSpatialTree(e,t){return!1}checkGeometriesIntersect(e,t,i,s){let n=e.getGeometryType(),o=t.getGeometryType();if(this.m_envGeomA.isIntersecting(this.m_envGeomB)){if(n===h.enumPoint&&t.getDimension()===2){const c=[0],l=[e.getXY()];if(J(t,l,1,this.m_tolerance,c),c[0]!==0)return i.outPoint.assign(l[0]),s.outPoint.assign(l[0]),!0}else if(o===h.enumPoint&&e.getDimension()===2){const c=[2],l=[t.getXY()];if(J(e,l,1,this.m_tolerance,c),c[0]!==0)return i.outPoint.assign(l[0]),s.outPoint.assign(l[0]),!0}if(n===h.enumMultiPoint&&t.getDimension()===2)return this.multipointIntersectsArea(e,t,i,s);if(o===h.enumMultiPoint&&e.getDimension()===2)return this.multipointIntersectsArea(t,e,s,i);let a,m,r=e,u=t;if(n===h.enumEnvelope&&(a=this.envelopeToPolygon(e),r=a,n=h.enumPolygon),o===h.enumEnvelope&&(m=this.envelopeToPolygon(t),u=m,o=h.enumPolygon),at(n)&&at(o)){const c=r.querySegmentIterator(),l=u.querySegmentIterator(),x=mt(),g=mt();if(vt(r,u,c,l,x,g))return i.outPoint.assign(x.outPoint),s.outPoint.assign(x.outPoint),!0}}return!1}multipointIntersectsArea(e,t,i,s){const n=e.getPointCount();for(let o=0;o<n;++o){const a=[2],m=e.getXY(o);if(J(t,[m],1,this.m_tolerance,a),a[0]!==0)return i.outPoint.assign(m),s.outPoint.assign(m),!0}return!1}getNearestNeighbourVisitor(e,t,i,s,n,o,a){return S(0),{}}buildSpatialTree(e,t){S(0)}}export{Bt as J,Rt as K,ut as z};
