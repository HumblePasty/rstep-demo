import{kH as Pe,kF as T,kx as fe,fq as b,kC as I,le as Ee,kN as K,kG as _e,ln as Te,lr as ee,kQ as k,lu as Q,lv as ue,li as Ie,kA as M,kK as D,lw as Ge,lx as be,lg as De,kD as R,ly as ve,lz as me,l2 as je,kJ as ke,lA as z,kV as se,ld as re,lB as ye,kZ as oe,lC as de,fs as H,kU as J,kY as W,ft as Z,lq as we,lD as Se,lE as Re,l0 as xe}from"./index-CgLC99fU.js";import{o as qe}from"./OperatorShapePreservingDensify-Lnr-J0cW.js";function v(){return j(new I,-1,Number.NaN)}function j(o,e,t){return{m_coordinate:o.clone(),m_vertexIndex:e,m_geometryIndex:0,m_distance:t,m_bRightSide:!1,isEmpty:Ve}}function Ve(){return Number.isNaN(this.m_distance)}function te(o,e,t=-1,n=-1){if(o.isEmpty())return 3;const s=o.getGeometryType();if(Pe(s))return Ue(o,e,t,n);if(s===T.enumPolygon)return Xe(o,e,t,n);if(s===T.enumPolyline)return Ye(o,e,t,n);if(s===T.enumEnvelope){const r=new fe;return o.queryEnvelope(r),r.contains(e)?r.containsExclusive(e)?1:2:0}return 3}function Ue(o,e,t,n){if(t>=0||n>=0)return b("");if(o.isDegenerate(0))return o.getStartXY().equals(e)?2:3;if(!o.isCurve()){const f=I.orientationRobust(e,o.getStartXY(),o.getEndXY());return f<0?1:f>0?0:2}const s=o.getClosestCoordinate(e,!1),r=o.getTangent(s),m=o.getCoord2D(s),l=I.orientationRobust(e,m,m.add(r));return l<0?1:l>0?0:2}function Xe(o,e,t,n){(t>=0||n>=0)&&b("");const s=new fe;o.queryEnvelope(s);const r=Ee(o,e,0);return r===0?0:r===1?1:2}function Ye(o,e,t,n){(t<0&&n>=0||t>=0&&n<0)&&b("");const s=o.querySegmentIterator();if(t<0){let m=Number.MAX_VALUE,l=0;for(;s.nextPath();)for(;s.hasNextSegment();){const f=s.nextSegment(),c=f.getClosestCoordinate(e,!1),u=f.getCoord2D(c),x=I.sqrDistance(u,e);x<m?(l=1,t=s.getStartPointIndex(),n=s.getPathIndex(),m=x):x===m&&l++}if(l===0)return 3;if(l===1)return s.resetToVertex(t,n),te(s.nextSegment(),e)}const r=Fe();if(r.i1!==-1&&r.i2===-1)return r.bRight1?1:0;if(r.i1!==-1&&r.i2!==-1){if(r.bRight1===r.bRight2)return r.bRight1?1:0;{s.resetToVertex(r.i1,-1);const m=s.nextSegment().getTangent(1);s.resetToVertex(r.i2,-1);const l=s.nextSegment().getTangent(0);return m.crossProduct(l)>=0?1:0}}return s.resetToVertex(t,n),te(s.nextSegment(),e)}function Fe(o,e,t,n){return K(0),{}}class ze{getOperatorType(){return 10501}supportsCurves(){return!1}accelerateGeometry(e,t,n){return!1}canAccelerateGeometry(e){return!1}getNearestCoordinate(e,t,n,s,r,m){if(t.isNAN()&&b("NAN xy coordinates are not allowed"),e.isEmpty())return v();if(Number.isNaN(s)&&(s=0),s>=0||b("maxDeviationMeters"),e.getDimension()===0)return this.getNearestVertex(e,t,n);const l=e.getGeometryType();if(l===T.enumGeometryCollection){const P=e;let p=v();for(let G=0,w=P.getGeometryCount();G<w;++G){const F=P.getGeometry(G),U=this.getNearestCoordinate(F,t,n,s,r,m);if(!U.isEmpty()){if(U.m_distance===0)return U;U.m_distance>=p.m_distance||(p=U,p.m_geometryIndex=G)}}return p}if(l===T.enumEnvelope){const P=new _e;return P.addEnvelope(e,!1),this.getNearestCoordinate(P,t,n,s,r,m)}Te(l)||ee("Operation is not implemented for this geometry type");const f=e;if((r||m)&&l===T.enumPolygon){const P=()=>{const p=j(t,-1,0);return p.m_bRightSide=!0,p};if(n.isPannable()){const p=new k().foldInto360Range(new Q(t),n);if(p.isEmpty())return v();const G=new k().foldInto360Range(e,n);if(G.isEmpty())return v();if(new ue().execute(G,p,n,null)&&r)return P()}else{const p=new k().clipToSpatialReference(new Q(t),n,null,1);if(p.isEmpty())return v();const G=Ie(f,n,0,null);if(G.isEmpty())return v();if(new ue().execute(G,p,n,null)&&r)return P()}}const c=n!==n.getGCS()?n.getSRToGCSTransform():null,u=new I;if(c?new k().transform(c,[t],1,[u],!1):u.assign(t),u.isNAN())return v();const x=ge(f,t,n,1);let y=x.m_distance;if(y===0)return x;Number.isNaN(y)?y=Number.POSITIVE_INFINITY:y*=1+1e-7;const h=n.getGCS(),C=h.getUnit().getUnitToBaseFactor(),_=u.clone();_.scale(C);const g=M();n.querySpheroidData(g);const a=D(g.majorSemiAxis,g.e2,_),N=Ge(g.majorSemiAxis,g.e2),A=new Me(f.querySegmentIterator());s===0&&(s=.01);const d=g.majorSemiAxis*be(45),i=new qe().executeMany(A,n,d,s,0,null),S=[];let Y=-1;const $=new R,B=new De;for(let P=i.next();P!==null;P=i.next()){if(P.isEmpty())continue;const p=i.getGeometryID(),G=e.getPathIndexFromPointIndex(p);e.isClosedPath(G)&&f.getPathEnd(G);const w=P;for(let F=0,U=w.getPathCount();F<U;++F){S.length=0;for(let E=w.getPathStart(F),X=w.getPathEnd(F);E<X;++E)S.push(w.getXY(E));if(c&&new k().transform(c,S,S.length,S,!1),S.length>3){const E=Ne(S,S.length,u,h,1);if(E.m_distance<y){y=E.m_distance,$.assign(D(g.majorSemiAxis,g.e2,E.m_coordinate.mul(C))),Y=p;let X=E.m_vertexIndex;X+1===S.length&&(X-=1),w.getSegmentBuffer(X,B,!0)}}S.forEach(E=>E.mulThis(C));const L=D(g.majorSemiAxis,g.e2,S[0]),pe=new R;for(let E=1,X=S.length;E<X;++E){const O=D(g.majorSemiAxis,g.e2,S[E]);if(ve(N,a,L,O,pe)<y){const{first:Le,second:Ce}=me(g.majorSemiAxis,g.e2,a,L,O,2,null);if(Ce<=y){const ce=new R,{first:Oe,second:le}=me(g.majorSemiAxis,g.e2,a,L,O,0,ce);le<y&&(y=le,$.assign(ce),Y=p,w.getSegmentBuffer(E-1,B,!0))}}L.assign(O)}}}if(!Number.isFinite(y))return v();Y===-1&&b("");const q=je(g.majorSemiAxis,g.e2,$);q.divThis(C);const V=q.clone(),ie=n!==n.getGCS()?n.getGCSToSRTransform():null;ie&&new k().transform(ie,[q],1,[V],!1),V.isNAN()&&ke("closestPoint2DSr.isNAN()"),K(!B.empty());const he=B.get().getClosestCoordinate(V,!1);V.assign(B.get().getCoord2D(he)),c?new k().transform(c,[V],1,[q],!1):q.assign(V),K(!q.isNAN());const Ae=this.getNearestVertex(new Q(q),u,n.getGCS()),ae=j(V,Y,Ae.m_distance);if(m&&e.getDimension()>0){const P=te(e,t,-1,-1),p=P!==0&&P!==3;ae.m_bRightSide=p}return ae}getNearestVertex(e,t,n){if(t.isNAN()&&b("NAN xy coordinates are not allowed"),e.isEmpty())return v();switch(e.getGeometryType()){case T.enumPoint:return ne(e,t,n);case T.enumMultiPoint:case T.enumPolyline:case T.enumPolygon:return ge(e,t,n);default:ee("")}}getNearestVertexPoint2D(e,t,n,s){return K(0),{}}getNearestVertices(e,t,n,s,r){if(t.isNAN()&&b("NAN xy coordinates are not allowed"),e.isEmpty())return[];switch(e.getGeometryType()){case T.enumPoint:{const m=ne(e,t,n);if(!m.isEmpty()&&m.m_distance<s&&r>=1){const l=[];return l.push(m),l}return[]}case T.enumMultiPoint:case T.enumPolyline:case T.enumPolygon:return Be(e,t,n,s,r);default:ee("")}}}function ne(o,e,t){const n={stack:[],error:void 0,hasError:!1};try{if(t.getCoordinateSystemType()===0&&b("Cannot use local SR"),t.getCoordinateSystemType()!==1){const u=new Array(2);u[0]=o.getXY(),u[1]=e.clone();const x=Se(I,2);Re(t,u,2,x)!==2&&b("Point cannot be projected to GCS");const y=t.getGCS(),h=ne(new Q(x[0]),x[1],y);return j(h.m_coordinate,0,h.m_distance)}const s=t.getUnit().getUnitToBaseFactor(),r=o.getXY();r.scale(s);const m=e.clone();m.scale(s);const l=M();t.querySpheroidData(l);const f=H(n,new J,!1);W.geodeticDistance(l.majorSemiAxis,l.e2,r.x,r.y,m.x,m.y,f,null,null,xe.PE_LINETYPE_GEODESIC);const c=o.getXY();return j(c,0,f.val)}catch(s){n.error=s,n.hasError=!0}finally{Z(n)}}function ge(o,e,t,n=0){t.getCoordinateSystemType()===0&&b("Cannot use local SR");let s=o.getAttributeStreamRef(0),r=o.getPointCount();const m=t.getGCS(),l=e.clone();if(t.getCoordinateSystemType()!==1){const d=t.getSRToGCSTransform();if(z(d,[e],1,[l],null),l.isNAN())return j(I.getNAN(),-1,Number.NaN);const i=new k().execute(o,d,null);s=i.getAttributeStreamRef(0),r=i.getPointCount()}const f=m.getUnit().getUnitToBaseFactor(),c=se(r,0);for(let d=0;d<r;++d)c[d]=d;re(r,c);const u=M();m.querySpheroidData(u);const x=l.clone();x.scale(f);const y=D(u.majorSemiAxis,u.e2,x);let h=-1,C=Number.MAX_VALUE;const _=ye(u.majorSemiAxis,u.e2);let g=r;const a=new I,N=new I;for(let d=0;d<g;){if(s.queryPoint2D(2*c[d],a),a.isNAN())continue;N.assign(a),N.scale(f);const i=D(u.majorSemiAxis,u.e2,N);if(R.distance(i,y)>C){c[g-1]=oe(c[d],c[d]=c[g-1]),g--;continue}const S=de(_,i,y);S<C&&(h=c[d],C=S),d++}if(u.e2!==0){const d={stack:[],error:void 0,hasError:!1};try{const i=H(d,new J,!1);for(let S=0;S<g;S++){if(s.queryPoint2D(2*c[S],a),a.isNAN())continue;N.assign(a),N.scale(f);const Y=D(u.majorSemiAxis,u.e2,N);R.distance(Y,y)>C||(W.geodeticDistance(u.majorSemiAxis,u.e2,x.x,x.y,N.x,N.y,i,null,null,n),i.val<C&&(h=c[S],C=i.val))}}catch(i){d.error=i,d.hasError=!0}finally{Z(d)}}const A=new I;return h!==-1&&A.assign(o.getXY(h)),j(A,h,C)}function Ne(o,e,t,n,s=0){n.getCoordinateSystemType()===0&&b("Cannot use local SR");const r=n.getGCS(),m=t.clone();if(n.getCoordinateSystemType()!==1){const a=n.getSRToGCSTransform();if(z(a,[t],1,[m],null),m.isNAN())return v();const N=Se(I,e);z(a,o,e,N,null);const A=Ne(N,e,t,r,s);return A.isEmpty()?A:j(o[A.m_vertexIndex],A.m_vertexIndex,A.m_distance)}const l=r.getUnit().getUnitToBaseFactor(),f=se(e,0);for(let a=0;a<e;++a)f[a]=a;re(e,f);const c=M();r.querySpheroidData(c);const u=m.clone();u.scale(l);const x=D(c.majorSemiAxis,c.e2,u);let y=-1,h=Number.MAX_VALUE;const C=ye(c.majorSemiAxis,c.e2);let _=e;for(let a=0;a<_;){const N=o[f[a]];if(N.isNAN())continue;const A=N.clone();A.scale(l);const d=D(c.majorSemiAxis,c.e2,A);if(R.distance(d,x)>h){f[_-1]=oe(f[a],f[a]=f[_-1]),_--;continue}const i=de(C,d,x);i<h&&(y=f[a],h=i),a++}if(c.e2!==0){const a={stack:[],error:void 0,hasError:!1};try{const N=H(a,new J,!1);for(let A=0;A<_;A++){const d=o[f[A]];if(d.isNAN())continue;const i=d.clone();i.scale(l);const S=D(c.majorSemiAxis,c.e2,i);R.distance(S,x)>h||(W.geodeticDistance(c.majorSemiAxis,c.e2,u.x,u.y,i.x,i.y,N,null,null,s),N.val<h&&(y=f[A],h=N.val))}}catch(N){a.error=N,a.hasError=!0}finally{Z(a)}}const g=new I;return y!==-1&&g.assign(o[y]),j(g,y,h)}function Be(o,e,t,n,s){const r={stack:[],error:void 0,hasError:!1};try{t.getCoordinateSystemType()===0&&b("Cannot use local SR");let m=o.getAttributeStreamRef(0),l=o.getPointCount();const f=t.getGCS(),c=e.clone();if(t.getCoordinateSystemType()!==1){const i=t.getSRToGCSTransform();if(z(i,[e],1,[c],null),c.isNAN())return[];const S=new k().execute(o,i,null);m=S.getAttributeStreamRef(0),l=S.getPointCount()}const u=f.getUnit().getUnitToBaseFactor(),x=se(l,0);for(let i=0;i<l;++i)x[i]=i;re(l,x);const y=M();f.querySpheroidData(y);const h=c.clone();h.scale(u);const C=D(y.majorSemiAxis,y.e2,h),_=[];let g=l;const a=new I,N=new I;for(let i=0;i<g;){if(m.queryPoint2D(2*x[i],a),a.isNAN())continue;N.assign(a),N.scale(u);const S=D(y.majorSemiAxis,y.e2,N);R.distance(S,C)>n?(x[g-1]=oe(x[i],x[i]=x[g-1]),g--):i++}const A=(i,S)=>i.m_distance-S.m_distance,d=H(r,new J,!1);for(let i=0;i<g;i++)m.queryPoint2D(2*x[i],a),a.isNAN()||(W.geodeticDistance(y.majorSemiAxis,y.e2,h.x,h.y,a.x*u,a.y*u,d,null,null,xe.PE_LINETYPE_GEODESIC),d.val<n&&_.push(j(a,x[i],d.val)));return _.sort(A),_.slice(0,s)}catch(m){r.error=m,r.hasError=!0}finally{Z(r)}}class Me extends we{constructor(e){super(),this.m_first=!0,this.m_segIter=e,this.m_segIter.stripAttributes()}tock(){return!0}getRank(){return 1}next(){if(this.m_first){if(!this.m_segIter.nextPath())return null;this.m_first=!1}for(;;){if(this.m_segIter.hasNextSegment())return this.m_segIter.nextSegment().clone();if(!this.m_segIter.nextPath())break}return null}getGeometryID(){return this.m_segIter.getStartPointIndex()}}export{ze as OperatorProximityGeodesic};
