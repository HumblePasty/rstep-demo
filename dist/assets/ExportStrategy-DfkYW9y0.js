import{bV as E,iG as P,x as w,eO as z,fi as $,cI as N,df as H,cD as T,G as I,r as d,o as l,p as q}from"./index-CW6gHi3a.js";import{S as B}from"./Bitmap-j-dQEQv6.js";import{h as C}from"./Tile-Dz_dvAiT.js";import{e as G}from"./TileKey-gYTcETqi.js";const O=Math.PI/180;function V(i){return i*O}function k(i,e){const s=V(e.rotation),t=Math.abs(Math.cos(s)),r=Math.abs(Math.sin(s)),[o,n]=e.size;return i[0]=Math.round(n*r+o*t),i[1]=Math.round(n*t+o*r),i}function A(i,e,s,t){const[r,o]=e,[n,a]=t,m=.5*s;return i[0]=r-m*n,i[1]=o-m*a,i[2]=r+m*n,i[3]=o+m*a,i}const u=N(),c=[0,0],_=new G(0,0,0,0),y={imageMaxWidth:2048,imageMaxHeight:2048,imageRotationSupported:!1,imageNormalizationSupported:!1,hidpi:!1};let h=class extends E{constructor(i){super(i),this._imagePromise=null,this.bitmaps=[],this.hidpi=y.hidpi,this.imageMaxWidth=y.imageMaxWidth,this.imageMaxHeight=y.imageMaxHeight,this.imageRotationSupported=y.imageRotationSupported,this.imageNormalizationSupported=y.imageNormalizationSupported,this.update=P(async(e,s)=>{if(w(s),!e.stationary||this.destroyed)return;const t=e.state,r=H(t.spatialReference),o=this.hidpi?e.pixelRatio:1,n=t.worldScreenWidth>0,a=n&&this.imageNormalizationSupported&&t.worldScreenWidth<t.size[0],m=Math.round((this.imageMaxWidth??0)/o),f=Math.round((this.imageMaxHeight??0)/o);a?(c[0]=t.worldScreenWidth,c[1]=t.size[1]):this.imageRotationSupported?(c[0]=t.size[0],c[1]=t.size[1]):k(c,t);const M=Math.floor(c[0])>m||Math.floor(c[1])>f,S=r&&(t.extent.xmin<r.valid[0]||t.extent.xmax>r.valid[1]),v=!this.imageNormalizationSupported&&S,x=!M&&!v,W=this.imageRotationSupported?t.rotation:0,b=this.container.children.slice();if(x){const p=a?t.paddedViewState.center:t.center;this._imagePromise=this._singleExport(t,c,p,t.resolution,W,o,s)}else{let p=Math.min(m,f);n&&(p=Math.min(t.worldScreenWidth,p),p=Math.round(t.worldScreenWidth/Math.ceil(t.worldScreenWidth/p))),this._imagePromise=this._tiledExport(t,p,o,s)}try{const p=await this._imagePromise??[];w(s);const R=[];if(this._imagePromise=null,this.destroyed)return;this.bitmaps=p;for(const g of b)p.includes(g)||R.push(g.fadeOut().then(()=>{g.remove(),g.destroy()}));for(const g of p)R.push(g.fadeIn());await Promise.all(R)}catch(p){this._imagePromise=null,T(p)}},5e3),this.updateExports=P(async e=>{const s=[];for(const t of this.container.children){if(!t.visible||!t.stage)return;s.push(e(t).then(()=>{t.invalidateTexture(),t.requestRender()}))}this._imagePromise=I(s).then(()=>this._imagePromise=null),await this._imagePromise})}destroy(){this.bitmaps.forEach(i=>i.destroy()),this.bitmaps=[]}get updating(){return!this.destroyed&&this._imagePromise!==null}async _export(i,e,s,t,r,o){const n=await this.fetchSource(i,Math.floor(e*r),Math.floor(s*r),{rotation:t,pixelRatio:r,signal:o});w(o);const a=new B(null,!0);return a.x=i.xmin,a.y=i.ymax,a.resolution=i.width/e,a.rotation=t,a.pixelRatio=r,a.opacity=0,this.container.addChild(a),await a.setSourceAsync(n,o),w(o),a}async _singleExport(i,e,s,t,r,o,n){A(u,s,t,e);const a=z(u,i.spatialReference);return[await this._export(a,e[0],e[1],r,o,n)]}_tiledExport(i,e,s,t){const r=$.create({size:e,spatialReference:i.spatialReference,scales:[i.scale]}),o=new C(r),n=o.getTileCoverage(i);if(!n)return null;const a=[];return n.forEach((m,f,M,S)=>{_.set(m,f,M,0),o.getTileBounds(u,_);const v=z(u,i.spatialReference);a.push(this._export(v,e,e,0,s,t).then(x=>(S!==0&&(_.set(m,f,M,S),o.getTileBounds(u,_),x.x=u[0],x.y=u[3]),x)))}),Promise.all(a)}};d([l()],h.prototype,"_imagePromise",void 0),d([l()],h.prototype,"bitmaps",void 0),d([l()],h.prototype,"container",void 0),d([l()],h.prototype,"fetchSource",void 0),d([l()],h.prototype,"hidpi",void 0),d([l()],h.prototype,"imageMaxWidth",void 0),d([l()],h.prototype,"imageMaxHeight",void 0),d([l()],h.prototype,"imageRotationSupported",void 0),d([l()],h.prototype,"imageNormalizationSupported",void 0),d([l()],h.prototype,"requestUpdate",void 0),d([l()],h.prototype,"updating",null),h=d([q("esri.views.2d.layers.support.ExportStrategy")],h);const J=h;export{J as _};
